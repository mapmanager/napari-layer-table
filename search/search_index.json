{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to napari-layer-table","text":"<p>A Napari plugin to display a layer as a table. We currently handle point, shape, and labeled layers.</p> <p></p>"},{"location":"#interface-overview","title":"Interface overview","text":"<ul> <li>The selected layer is displayed in the table.</li> <li> <p>The table has columns for:</p> <ul> <li>Point symbol with face color</li> <li>Point coordinates (x,y,z)</li> <li>If the layer has properties, these are also columns</li> </ul> </li> <li> <p>Bi-directional selection between layer and table.</p> </li> <li>Bi-directional delete between layer and table.</li> <li>Points added to the layer are added to the table.</li> <li>Points moved in the layer are updated in the table.</li> <li>Changes to face color and symbol in the layer are updated in the table.</li> </ul> <p>Right-click for context menu to:</p> <ul> <li>Toggle table columns on/off.</li> <li>Toggle shift+click to add a point to the layer (no need to switch viewer mode)</li> <li>Copy table to clipboard</li> </ul>"},{"location":"#how-to-use","title":"How to use","text":"<ul> <li>Select a points layer in the napari viewer and run the plugin</li> </ul>"},{"location":"#include-in-your-own-code","title":"Include in your own code","text":"<p>It is easy to include the napari-layer-table plugin in your own custom code. See Scripting for more information.</p>"},{"location":"#future-directions","title":"Future directions","text":"<p>We are working to extend the plugin to display a table for other Napari layer types including: Labels, Shapes, Tracks, and Vectors.</p>"},{"location":"scripting/","title":"Scripting","text":"<p>It is easy to use the napari-layer-table from your own code.</p> <p>TODO: How do we link to the examples/ folder in the repo?</p> <p>See example scripts in examples/</p> <pre><code># create viewer\n\n# create layer\n\n# run the plugin\n\n# connect to plugin signal/slot\n</code></pre>"},{"location":"api/_data_model/","title":"_data_model","text":"<p>               Bases: <code>QAbstractTableModel</code></p> Source code in <code>src/napari_layer_table/_data_model.py</code> <pre><code>class pandasModel(QtCore.QAbstractTableModel):\n\n    #signalMyDataChanged = QtCore.pyqtSignal(object, object, object)\n    signalMyDataChanged = QtCore.Signal(object, object, object)\n    \"\"\"Emit on user editing a cell.\"\"\"\n\n    def __init__(self, data : pd.DataFrame):\n        \"\"\"Data model for a pandas dataframe.\n\n        Args:\n            data (pd.dataframe): pandas dataframe\n        \"\"\"\n        QtCore.QAbstractTableModel.__init__(self)\n\n        self._data = data\n\n    def rowCount(self, parent=None):\n        return self._data.shape[0]\n\n    def columnCount(self, parnet=None):\n        return self._data.shape[1]\n\n    def data(self, index, role=QtCore.Qt.DisplayRole):\n        \"\"\"\n        QtDocs: \"Returns the data stored under the given role for the item referred to by the index.\"\n\n        Parameters\n        ----------\n        index : PyQt5.QtCore.QModelIndex\n        role : \n        \"\"\"\n        #logger.info(f'index:{index.row()} {index.column()} {index}')\n        if index.isValid():\n            if role == QtCore.Qt.ToolTipRole:\n                # no tooltips here\n                pass\n            #elif role in [QtCore.Qt.DisplayRole, QtCore.Qt.EditRole]:\n            elif role in [QtCore.Qt.DisplayRole]:\n                columnName = self._data.columns[index.column()]\n\n                realRow = index.row()\n                retVal = self._data.loc[realRow, columnName]\n\n                #time.sleep(0.1)\n\n                if columnName == 'accept' and realRow==1:\n                    # logger.info(' ======================================= accept column')\n                    # print('  index.row():', index.row())\n                    # print('  index.column():', index.column())\n                    # print('  realRow:', realRow)\n                    # print('  columnName:', columnName)\n                    # print(f'  self._data.loc[realRow] is:')\n\n                    print(f'  (0) retVal is: \"{retVal}\"')\n\n                    # comment this and toggle with 'a' does not work\n                    print(self._data.loc[realRow])\n\n                    print(f'  (1) retVal is: \"{retVal}\"')\n\n                    # print(f'  self._data.loc[realRow, columnName] is \"{self._data.loc[realRow, columnName]}\"')\n                    # print('  self._data[\"accept\"]: is')\n                    # print(self._data[\"accept\"])\n                    # print('  self._data[\"x\"]: is')\n                    # print(self._data[\"x\"])\n                    # logger.info('  ========================================self._data is:')\n                    # print(self._data)\n                    # print('')\n\n                    pass\n\n                return str(retVal)\n                #return str(retVal)\n                #return QtCore.QVariant(retVal)\n\n                # if columnName == 'accept':\n                #     logger.info(f'orig retVal: \"{retVal}\" {type(retVal)}')\n                #     print('  self._data:')\n                #     print(self._data)\n\n                if isinstance(retVal, np.float64):\n                    retVal = float(retVal)\n                elif isinstance(retVal, np.int64):\n                    retVal = int(retVal)\n                elif isinstance(retVal, np.bool_):\n                    retVal = str(retVal)\n                elif isinstance(retVal, list):\n                    retVal = str(retVal)\n                elif isinstance(retVal, str) and retVal == 'nan':\n                    # logger.info('nan error 1')\n                    retVal = ''\n\n                elif isinstance(retVal, float) and math.isnan(retVal):\n                    # don't show 'nan' in table\n                    logger.info('nan error 2')\n                    retVal = ''\n                # added march 22\n                elif isinstance(retVal, str):\n                    logger.info(f'new mar 22 returning {retVal} {type(retVal)}')\n                    #retVal = retVal\n\n                if columnName == 'accept':\n                    logger.info(f'  returning realRow:{realRow} columnName:{columnName} retVal: \"{retVal}\"')\n\n                return retVal\n\n            elif role == QtCore.Qt.FontRole:\n                #realRow = self._data.index[index.row()]\n                realRow = index.row()\n                columnName = self._data.columns[index.column()]\n                if columnName == 'Symbol':\n                    # make symbols larger\n                    return QtCore.QVariant(QtGui.QFont('Arial', pointSize=14))\n                return QtCore.QVariant()\n\n            elif role == QtCore.Qt.ForegroundRole:\n                columnName = self._data.columns[index.column()]\n                colorColumns = ['Symbol', 'Shape Type']\n                #if columnName == 'Symbol':\n                if columnName in colorColumns:\n                    # don't get col from index, get from name\n                    realRow = self._data.index[index.row()]\n                    face_color = self._data.loc[realRow, 'Face Color'] # rgba\n                    # TODO: face_color is sometimes a scalar\n                    # try:\n                    #  _color = (np.array(color.getRgb()) / 255).astype(np.float32)\n                    try:\n                        #r = int(face_color[0] * 255)\n                        #g = int(face_color[1] * 255)\n                        #b = int(face_color[2] * 255)\n                        #alpha = int(face_color[3] * 255)\n                        #theColor = QtCore.QVariant(QtGui.QColor(r, g, b, alpha))\n                        # swap AA\n                        # napari uses proper order #RRGGBBAA\n                        # pyqt uses stange order #AARRGGBB\n                        face_color = face_color[0] + face_color[7:9] + face_color[1:7]\n                        theColor = QtCore.QVariant(QtGui.QColor(face_color))\n                        return theColor\n                    except (IndexError) as e:\n                        logger.error(f'expecting \"Face Color\"\" as list of rgba, got scalar of {face_color}')\n                        return QtCore.QVariant()\n                return QtCore.QVariant()\n\n            elif role == QtCore.Qt.BackgroundRole:\n                realRow = self._data.index[index.row()]\n\n                columnName = self._data.columns[index.column()]\n                if columnName == 'Face Color':\n                    realRow = self._data.index[index.row()]\n                    face_color = self._data.loc[realRow, 'Face Color'] # rgba\n                    face_color = face_color[0] + face_color[7:9] + face_color[1:7]\n                    theColor = QtCore.QVariant(QtGui.QColor(face_color))\n                    return theColor         \n                #elif index.row() % 2 == 0:\n                elif realRow % 2 == 0:\n                    return QtCore.QVariant(QtGui.QColor('#444444'))\n                else:\n                    return QtCore.QVariant(QtGui.QColor('#666666'))\n        #\n        return QtCore.QVariant()\n\n    def setData(self, index, value, role=QtCore.Qt.EditRole):\n        \"\"\"Respond to user/keyboard edits.\n\n            Qt docs: \"Sets the role data for the item at index to value.\"\n\n            True if value is changed. Calls layoutChanged after update.\n\n        Returns:\n            (bool): False if value is not different from original value.\n        \"\"\"\n        logger.info('THIS DOES NOT GET CAALLED    !!!!!!!!!!!!!')\n        if index.isValid():\n            if role == QtCore.Qt.EditRole:\n                rowIdx = index.row()\n                columnIdx = index.column()\n\n                # in general, DO NOT USE iloc, use loc as it is absolute (i,j)\n                columnName = self._data.columns[index.column()]\n                realRow = index.row()\n                v = self._data.loc[realRow, columnName]\n                if isinstance(v, np.float64):\n                    try:\n                        if value == '':\n                            value = np.nan\n                        else:\n                            value = float(value)\n                    except (ValueError) as e:\n                        logger.info('  No action --&gt;&gt; please enter a number')\n                        #self.signalUpdateStatus.emit('Please enter a number')\n                        return False\n\n                # set\n                self._data.loc[realRow, columnName] = value\n                #self._data.iloc[rowIdx, columnIdx] = value\n\n                # emit change\n                emitRowDict = self.myGetRowDict(realRow)\n                self.signalMyDataChanged.emit(columnName, value, emitRowDict)\n\n                return True\n\n        #\n        return QtCore.QVariant()\n\n    def flags(self, index):\n        if not index.isValid():\n            logger.warning(f'index is not valid: {index}')\n\n        rowIdx = index.row()\n        columnIdx = index.column()\n\n        # use to check isEditable\n        try:\n            columnName = self._data.columns[columnIdx]\n        except(IndexError) as e:\n            logger.warning(f'IndexError for columnIdx:{columnIdx} len:{len(self._data.columns)}')\n            print('  self._data.columns:', self._data.columns)\n            raise\n\n        theRet = QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable\n\n        # isEditable = True\n        # isCheckbox = False\n        # if isEditable:\n        #     theRet |= QtCore.Qt.ItemIsEditable\n        # if isCheckbox:\n        #     #logger.info(f'isCheckbox {columnIdx}')\n        #     theRet |= QtCore.Qt.ItemIsUserCheckable\n\n        # flags |= QtCore.Qt.ItemIsEditable | QtCore.Qt.ItemIsUserCheckable | Qt.ItemIsEnabled\n\n        return theRet\n\n    def headerData(self, col, orientation, role):\n        if role == QtCore.Qt.DisplayRole:\n            if orientation == QtCore.Qt.Horizontal:\n                try:\n                    return self._data.columns[col]\n                except(IndexError) as e:\n                    logger.warning(f'IndexError for col:{col} len:{len(self._data.columns)}, shape:{self._data.shape}')\n                    #raise\n            elif orientation == QtCore.Qt.Vertical:\n                # this is to show pandas 'index' column\n                return col\n\n        return QtCore.QVariant()\n\n    def old_sort(self, Ncol, order):\n        \"\"\"Not used when we have a sort model proxy.\n        \"\"\"\n        logger.info(f'Ncol:{Ncol} order:{order}')\n        self.layoutAboutToBeChanged.emit()\n        self._data = self._data.sort_values(self._data.columns[Ncol], ascending=not order)\n        self.layoutChanged.emit()\n\n    def myCopyTable(self):\n        \"\"\"Copy model data to clipboard.\n        \"\"\"\n        dfCopy = self._data.copy()\n        dfCopy.to_clipboard(sep='\\t', index=False)\n        logger.info(f'Copied table to clipboard with shape: {dfCopy.shape}')\n        pprint(dfCopy)\n\n    def myAppendRow(self, dfRow : pd.DataFrame = None):\n        \"\"\"Append one row to internal DataFrame.\n\n        Args:\n            dfRow (pd.DataFrame): One row DataFrame to append.\n        \"\"\"\n        if dfRow.empty:\n            return\n\n        logger.info('')\n        # append one empty row\n        newRowIdx = len(self._data)\n        self.beginInsertRows(QtCore.QModelIndex(), newRowIdx, newRowIdx)\n\n        self._data = pd.concat([self._data, dfRow], ignore_index=True)\n\n        self.endInsertRows()\n\n    def myDeleteRows(self, rows: list):\n        \"\"\"Delete a list of rows from model.\n\n        Args:\n            rows (list of int): row indices to delete\n\n        TODO: get update of rows to work\n        \"\"\"\n        logger.info('qqqqqqq  wwwwwww')\n        # minRow = min(rows)\n        # maxRow = max(rows)\n        # want this\n        # self.beginRemoveRows(QtCore.QModelIndex(), minRow, maxRow)\n        self.beginResetModel()\n\n        self._data = self._data.drop(rows)\n        self._data = self._data.reset_index(drop=True)\n\n        # want this\n        # self.endRemoveRows()\n        self.endResetModel()\n\n    def mySetRow(self, rowList: List[int], df: pd.DataFrame, ignoreAccept : bool = False):\n        \"\"\"Set a number of rows from a pandas dataframe.\n\n        Args:\n            rowList (list of int): row indices to change\n            df (pd.Dataframe): DataFrame with new values for each row in rowList.\n                Rows of dataframe correspond to enumeration of rowList list\n            ignoreAccept (bool): If True then do not assign 'accept' column\n                This is used when user moves a point\n                Napari layer does not know about accept\n        \"\"\"\n\n        # logger.info(f'  === (0) received rowList and df, df type is {type(df)}')\n        # logger.info(f'                       rowList:{rowList}')\n        # logger.info('  df')\n        # print(df)\n\n        # print('   before we do anything, self._data is:')\n        # print(self._data)\n\n        # print('          Mar 22, HERE IS WERE WE SET DATA AND IT DOES NOT GET UPDATED XXXXXXXXXXXXXX')\n\n        for dfIdx, rowIdx in enumerate(rowList):\n            # on switching to v2, was giving error\n            # our df has row indices matching the changed rows (same as rowList)\n\n            # ARRRGGGGG, 20230323, without copy this does not work !!!!!\n            #oneRow = df.loc[rowIdx].copy()\n            oneRow = df.loc[rowIdx]\n\n            # print('(0.0) oneRow is type', type(oneRow), 'and had values of:')\n            # print(oneRow)\n\n            #IndexError: iloc cannot enlarge its target object\n            try:\n                # logger.info(f'  setting rowIdx:{rowIdx} to oneRow from df')\n                # print(f'      setting one row to new values oneRow is:')\n                # print(oneRow)\n                # print(f'=== (1) row {rowIdx} before set is:')\n                # print(self._data.loc[rowIdx])\n\n                #\n                # set\n                #\n                #oneRow['accept'] = 999\n                #self._data.loc[rowIdx] = oneRow\n\n                # accept column is owned by layer table and is not in lanapri layer\n\n                # oneRow is a pandas.core.series.Series\n                if ignoreAccept:\n                    _oneRowDict = oneRow.to_dict()\n                    for k,v in _oneRowDict.items():\n                        if k == 'accept':\n                            continue\n                        self._data.loc[rowIdx, k] = v\n                else:\n                    self._data.loc[rowIdx] = oneRow\n\n                # print('  === (2) row after set is:')\n                # print(self._data.loc[rowIdx])\n\n                # print('  === (2.5) \"accept\" col after set self._data[\"accept\"] is')\n                # print(self._data['accept'])\n                # print(self._data['x'])\n\n                # print('   self._data.columns is:')\n                # print(self._data.columns)\n\n                # print('  === (2) self._data after set is:')\n                # print(self._data)\n\n            except (ValueError) as e:\n                logger.error(e)\n                logger.error(f'rowIdx: {rowIdx}')\n                logger.error(f'oneRow: {oneRow}')\n\n            startIdx = self.index(rowIdx, 0)  # QModelIndex\n            stopIdx = self.index(rowIdx, self._data.shape[1]-1)  # QModelIndex\n\n            #stopIdx = self.index(rowIdx+1, self._data.shape[1]-1)  # QModelIndex\n\n            #print('  startIdx:', startIdx.row(), startIdx.column())\n            #print('  stopIdx:', stopIdx.row(), stopIdx.column())\n\n            # logger.info(f'  XXXXXXXX startIdx:{startIdx.row()} {startIdx.column()}')\n            # logger.info(f'  XXXXXXXX stopIdx:{stopIdx.row()} {stopIdx.column()}')\n\n            # does nothing\n            #self.dataChanged.emit(startIdx, stopIdx)\n\n            # print('           --&gt;&gt; self.dataChanged.emit with:')\n            # print('            startIdx:', startIdx.row(), startIdx.column())\n            # print('            stopIdx:', stopIdx.row(), stopIdx.column())\n            #self.dataChanged.emit(startIdx, stopIdx, [QtCore.Qt.DisplayRole])\n            self.dataChanged.emit(startIdx, stopIdx)\n\n            # logger.info('(4) at end')\n            # print(self._data)\n            # print(self._data['accept'])\n\n        return True\n\n    def old_myGetValue(self, rowIdx, colStr):\n        val = None\n        if colStr not in self._data.columns:  #  columns is a list\n            logger.error(f'Got bad column name: \"{colStr}\"')\n        elif len(self._data)-1 &lt; rowIdx:\n            logger.error(f'Got bad row:{rowIdx} from possible {len(self._data)}')\n        else:\n            val = self._data.loc[rowIdx, colStr]\n        return val\n\n    def myGetData(self):\n        return self._data\n</code></pre>"},{"location":"api/_data_model/#napari_layer_table._data_model.pandasModel.signalMyDataChanged","title":"<code>signalMyDataChanged = QtCore.Signal(object, object, object)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Emit on user editing a cell.</p>"},{"location":"api/_data_model/#napari_layer_table._data_model.pandasModel.__init__","title":"<code>__init__(data)</code>","text":"<p>Data model for a pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dataframe</code> <p>pandas dataframe</p> required Source code in <code>src/napari_layer_table/_data_model.py</code> <pre><code>def __init__(self, data : pd.DataFrame):\n    \"\"\"Data model for a pandas dataframe.\n\n    Args:\n        data (pd.dataframe): pandas dataframe\n    \"\"\"\n    QtCore.QAbstractTableModel.__init__(self)\n\n    self._data = data\n</code></pre>"},{"location":"api/_data_model/#napari_layer_table._data_model.pandasModel.data","title":"<code>data(index, role=QtCore.Qt.DisplayRole)</code>","text":"<p>QtDocs: \"Returns the data stored under the given role for the item referred to by the index.\"</p>"},{"location":"api/_data_model/#napari_layer_table._data_model.pandasModel.data--parameters","title":"Parameters","text":"<p>index : PyQt5.QtCore.QModelIndex role :</p> Source code in <code>src/napari_layer_table/_data_model.py</code> <pre><code>def data(self, index, role=QtCore.Qt.DisplayRole):\n    \"\"\"\n    QtDocs: \"Returns the data stored under the given role for the item referred to by the index.\"\n\n    Parameters\n    ----------\n    index : PyQt5.QtCore.QModelIndex\n    role : \n    \"\"\"\n    #logger.info(f'index:{index.row()} {index.column()} {index}')\n    if index.isValid():\n        if role == QtCore.Qt.ToolTipRole:\n            # no tooltips here\n            pass\n        #elif role in [QtCore.Qt.DisplayRole, QtCore.Qt.EditRole]:\n        elif role in [QtCore.Qt.DisplayRole]:\n            columnName = self._data.columns[index.column()]\n\n            realRow = index.row()\n            retVal = self._data.loc[realRow, columnName]\n\n            #time.sleep(0.1)\n\n            if columnName == 'accept' and realRow==1:\n                # logger.info(' ======================================= accept column')\n                # print('  index.row():', index.row())\n                # print('  index.column():', index.column())\n                # print('  realRow:', realRow)\n                # print('  columnName:', columnName)\n                # print(f'  self._data.loc[realRow] is:')\n\n                print(f'  (0) retVal is: \"{retVal}\"')\n\n                # comment this and toggle with 'a' does not work\n                print(self._data.loc[realRow])\n\n                print(f'  (1) retVal is: \"{retVal}\"')\n\n                # print(f'  self._data.loc[realRow, columnName] is \"{self._data.loc[realRow, columnName]}\"')\n                # print('  self._data[\"accept\"]: is')\n                # print(self._data[\"accept\"])\n                # print('  self._data[\"x\"]: is')\n                # print(self._data[\"x\"])\n                # logger.info('  ========================================self._data is:')\n                # print(self._data)\n                # print('')\n\n                pass\n\n            return str(retVal)\n            #return str(retVal)\n            #return QtCore.QVariant(retVal)\n\n            # if columnName == 'accept':\n            #     logger.info(f'orig retVal: \"{retVal}\" {type(retVal)}')\n            #     print('  self._data:')\n            #     print(self._data)\n\n            if isinstance(retVal, np.float64):\n                retVal = float(retVal)\n            elif isinstance(retVal, np.int64):\n                retVal = int(retVal)\n            elif isinstance(retVal, np.bool_):\n                retVal = str(retVal)\n            elif isinstance(retVal, list):\n                retVal = str(retVal)\n            elif isinstance(retVal, str) and retVal == 'nan':\n                # logger.info('nan error 1')\n                retVal = ''\n\n            elif isinstance(retVal, float) and math.isnan(retVal):\n                # don't show 'nan' in table\n                logger.info('nan error 2')\n                retVal = ''\n            # added march 22\n            elif isinstance(retVal, str):\n                logger.info(f'new mar 22 returning {retVal} {type(retVal)}')\n                #retVal = retVal\n\n            if columnName == 'accept':\n                logger.info(f'  returning realRow:{realRow} columnName:{columnName} retVal: \"{retVal}\"')\n\n            return retVal\n\n        elif role == QtCore.Qt.FontRole:\n            #realRow = self._data.index[index.row()]\n            realRow = index.row()\n            columnName = self._data.columns[index.column()]\n            if columnName == 'Symbol':\n                # make symbols larger\n                return QtCore.QVariant(QtGui.QFont('Arial', pointSize=14))\n            return QtCore.QVariant()\n\n        elif role == QtCore.Qt.ForegroundRole:\n            columnName = self._data.columns[index.column()]\n            colorColumns = ['Symbol', 'Shape Type']\n            #if columnName == 'Symbol':\n            if columnName in colorColumns:\n                # don't get col from index, get from name\n                realRow = self._data.index[index.row()]\n                face_color = self._data.loc[realRow, 'Face Color'] # rgba\n                # TODO: face_color is sometimes a scalar\n                # try:\n                #  _color = (np.array(color.getRgb()) / 255).astype(np.float32)\n                try:\n                    #r = int(face_color[0] * 255)\n                    #g = int(face_color[1] * 255)\n                    #b = int(face_color[2] * 255)\n                    #alpha = int(face_color[3] * 255)\n                    #theColor = QtCore.QVariant(QtGui.QColor(r, g, b, alpha))\n                    # swap AA\n                    # napari uses proper order #RRGGBBAA\n                    # pyqt uses stange order #AARRGGBB\n                    face_color = face_color[0] + face_color[7:9] + face_color[1:7]\n                    theColor = QtCore.QVariant(QtGui.QColor(face_color))\n                    return theColor\n                except (IndexError) as e:\n                    logger.error(f'expecting \"Face Color\"\" as list of rgba, got scalar of {face_color}')\n                    return QtCore.QVariant()\n            return QtCore.QVariant()\n\n        elif role == QtCore.Qt.BackgroundRole:\n            realRow = self._data.index[index.row()]\n\n            columnName = self._data.columns[index.column()]\n            if columnName == 'Face Color':\n                realRow = self._data.index[index.row()]\n                face_color = self._data.loc[realRow, 'Face Color'] # rgba\n                face_color = face_color[0] + face_color[7:9] + face_color[1:7]\n                theColor = QtCore.QVariant(QtGui.QColor(face_color))\n                return theColor         \n            #elif index.row() % 2 == 0:\n            elif realRow % 2 == 0:\n                return QtCore.QVariant(QtGui.QColor('#444444'))\n            else:\n                return QtCore.QVariant(QtGui.QColor('#666666'))\n    #\n    return QtCore.QVariant()\n</code></pre>"},{"location":"api/_data_model/#napari_layer_table._data_model.pandasModel.myAppendRow","title":"<code>myAppendRow(dfRow=None)</code>","text":"<p>Append one row to internal DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>dfRow</code> <code>DataFrame</code> <p>One row DataFrame to append.</p> <code>None</code> Source code in <code>src/napari_layer_table/_data_model.py</code> <pre><code>def myAppendRow(self, dfRow : pd.DataFrame = None):\n    \"\"\"Append one row to internal DataFrame.\n\n    Args:\n        dfRow (pd.DataFrame): One row DataFrame to append.\n    \"\"\"\n    if dfRow.empty:\n        return\n\n    logger.info('')\n    # append one empty row\n    newRowIdx = len(self._data)\n    self.beginInsertRows(QtCore.QModelIndex(), newRowIdx, newRowIdx)\n\n    self._data = pd.concat([self._data, dfRow], ignore_index=True)\n\n    self.endInsertRows()\n</code></pre>"},{"location":"api/_data_model/#napari_layer_table._data_model.pandasModel.myCopyTable","title":"<code>myCopyTable()</code>","text":"<p>Copy model data to clipboard.</p> Source code in <code>src/napari_layer_table/_data_model.py</code> <pre><code>def myCopyTable(self):\n    \"\"\"Copy model data to clipboard.\n    \"\"\"\n    dfCopy = self._data.copy()\n    dfCopy.to_clipboard(sep='\\t', index=False)\n    logger.info(f'Copied table to clipboard with shape: {dfCopy.shape}')\n    pprint(dfCopy)\n</code></pre>"},{"location":"api/_data_model/#napari_layer_table._data_model.pandasModel.myDeleteRows","title":"<code>myDeleteRows(rows)</code>","text":"<p>Delete a list of rows from model.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>list of int</code> <p>row indices to delete</p> required <p>TODO: get update of rows to work</p> Source code in <code>src/napari_layer_table/_data_model.py</code> <pre><code>def myDeleteRows(self, rows: list):\n    \"\"\"Delete a list of rows from model.\n\n    Args:\n        rows (list of int): row indices to delete\n\n    TODO: get update of rows to work\n    \"\"\"\n    logger.info('qqqqqqq  wwwwwww')\n    # minRow = min(rows)\n    # maxRow = max(rows)\n    # want this\n    # self.beginRemoveRows(QtCore.QModelIndex(), minRow, maxRow)\n    self.beginResetModel()\n\n    self._data = self._data.drop(rows)\n    self._data = self._data.reset_index(drop=True)\n\n    # want this\n    # self.endRemoveRows()\n    self.endResetModel()\n</code></pre>"},{"location":"api/_data_model/#napari_layer_table._data_model.pandasModel.mySetRow","title":"<code>mySetRow(rowList, df, ignoreAccept=False)</code>","text":"<p>Set a number of rows from a pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>rowList</code> <code>list of int</code> <p>row indices to change</p> required <code>df</code> <code>Dataframe</code> <p>DataFrame with new values for each row in rowList. Rows of dataframe correspond to enumeration of rowList list</p> required <code>ignoreAccept</code> <code>bool</code> <p>If True then do not assign 'accept' column This is used when user moves a point Napari layer does not know about accept</p> <code>False</code> Source code in <code>src/napari_layer_table/_data_model.py</code> <pre><code>def mySetRow(self, rowList: List[int], df: pd.DataFrame, ignoreAccept : bool = False):\n    \"\"\"Set a number of rows from a pandas dataframe.\n\n    Args:\n        rowList (list of int): row indices to change\n        df (pd.Dataframe): DataFrame with new values for each row in rowList.\n            Rows of dataframe correspond to enumeration of rowList list\n        ignoreAccept (bool): If True then do not assign 'accept' column\n            This is used when user moves a point\n            Napari layer does not know about accept\n    \"\"\"\n\n    # logger.info(f'  === (0) received rowList and df, df type is {type(df)}')\n    # logger.info(f'                       rowList:{rowList}')\n    # logger.info('  df')\n    # print(df)\n\n    # print('   before we do anything, self._data is:')\n    # print(self._data)\n\n    # print('          Mar 22, HERE IS WERE WE SET DATA AND IT DOES NOT GET UPDATED XXXXXXXXXXXXXX')\n\n    for dfIdx, rowIdx in enumerate(rowList):\n        # on switching to v2, was giving error\n        # our df has row indices matching the changed rows (same as rowList)\n\n        # ARRRGGGGG, 20230323, without copy this does not work !!!!!\n        #oneRow = df.loc[rowIdx].copy()\n        oneRow = df.loc[rowIdx]\n\n        # print('(0.0) oneRow is type', type(oneRow), 'and had values of:')\n        # print(oneRow)\n\n        #IndexError: iloc cannot enlarge its target object\n        try:\n            # logger.info(f'  setting rowIdx:{rowIdx} to oneRow from df')\n            # print(f'      setting one row to new values oneRow is:')\n            # print(oneRow)\n            # print(f'=== (1) row {rowIdx} before set is:')\n            # print(self._data.loc[rowIdx])\n\n            #\n            # set\n            #\n            #oneRow['accept'] = 999\n            #self._data.loc[rowIdx] = oneRow\n\n            # accept column is owned by layer table and is not in lanapri layer\n\n            # oneRow is a pandas.core.series.Series\n            if ignoreAccept:\n                _oneRowDict = oneRow.to_dict()\n                for k,v in _oneRowDict.items():\n                    if k == 'accept':\n                        continue\n                    self._data.loc[rowIdx, k] = v\n            else:\n                self._data.loc[rowIdx] = oneRow\n\n            # print('  === (2) row after set is:')\n            # print(self._data.loc[rowIdx])\n\n            # print('  === (2.5) \"accept\" col after set self._data[\"accept\"] is')\n            # print(self._data['accept'])\n            # print(self._data['x'])\n\n            # print('   self._data.columns is:')\n            # print(self._data.columns)\n\n            # print('  === (2) self._data after set is:')\n            # print(self._data)\n\n        except (ValueError) as e:\n            logger.error(e)\n            logger.error(f'rowIdx: {rowIdx}')\n            logger.error(f'oneRow: {oneRow}')\n\n        startIdx = self.index(rowIdx, 0)  # QModelIndex\n        stopIdx = self.index(rowIdx, self._data.shape[1]-1)  # QModelIndex\n\n        #stopIdx = self.index(rowIdx+1, self._data.shape[1]-1)  # QModelIndex\n\n        #print('  startIdx:', startIdx.row(), startIdx.column())\n        #print('  stopIdx:', stopIdx.row(), stopIdx.column())\n\n        # logger.info(f'  XXXXXXXX startIdx:{startIdx.row()} {startIdx.column()}')\n        # logger.info(f'  XXXXXXXX stopIdx:{stopIdx.row()} {stopIdx.column()}')\n\n        # does nothing\n        #self.dataChanged.emit(startIdx, stopIdx)\n\n        # print('           --&gt;&gt; self.dataChanged.emit with:')\n        # print('            startIdx:', startIdx.row(), startIdx.column())\n        # print('            stopIdx:', stopIdx.row(), stopIdx.column())\n        #self.dataChanged.emit(startIdx, stopIdx, [QtCore.Qt.DisplayRole])\n        self.dataChanged.emit(startIdx, stopIdx)\n\n        # logger.info('(4) at end')\n        # print(self._data)\n        # print(self._data['accept'])\n\n    return True\n</code></pre>"},{"location":"api/_data_model/#napari_layer_table._data_model.pandasModel.old_sort","title":"<code>old_sort(Ncol, order)</code>","text":"<p>Not used when we have a sort model proxy.</p> Source code in <code>src/napari_layer_table/_data_model.py</code> <pre><code>def old_sort(self, Ncol, order):\n    \"\"\"Not used when we have a sort model proxy.\n    \"\"\"\n    logger.info(f'Ncol:{Ncol} order:{order}')\n    self.layoutAboutToBeChanged.emit()\n    self._data = self._data.sort_values(self._data.columns[Ncol], ascending=not order)\n    self.layoutChanged.emit()\n</code></pre>"},{"location":"api/_data_model/#napari_layer_table._data_model.pandasModel.setData","title":"<code>setData(index, value, role=QtCore.Qt.EditRole)</code>","text":"<p>Respond to user/keyboard edits.</p> <pre><code>Qt docs: \"Sets the role data for the item at index to value.\"\n\nTrue if value is changed. Calls layoutChanged after update.\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>False if value is not different from original value.</p> Source code in <code>src/napari_layer_table/_data_model.py</code> <pre><code>def setData(self, index, value, role=QtCore.Qt.EditRole):\n    \"\"\"Respond to user/keyboard edits.\n\n        Qt docs: \"Sets the role data for the item at index to value.\"\n\n        True if value is changed. Calls layoutChanged after update.\n\n    Returns:\n        (bool): False if value is not different from original value.\n    \"\"\"\n    logger.info('THIS DOES NOT GET CAALLED    !!!!!!!!!!!!!')\n    if index.isValid():\n        if role == QtCore.Qt.EditRole:\n            rowIdx = index.row()\n            columnIdx = index.column()\n\n            # in general, DO NOT USE iloc, use loc as it is absolute (i,j)\n            columnName = self._data.columns[index.column()]\n            realRow = index.row()\n            v = self._data.loc[realRow, columnName]\n            if isinstance(v, np.float64):\n                try:\n                    if value == '':\n                        value = np.nan\n                    else:\n                        value = float(value)\n                except (ValueError) as e:\n                    logger.info('  No action --&gt;&gt; please enter a number')\n                    #self.signalUpdateStatus.emit('Please enter a number')\n                    return False\n\n            # set\n            self._data.loc[realRow, columnName] = value\n            #self._data.iloc[rowIdx, columnIdx] = value\n\n            # emit change\n            emitRowDict = self.myGetRowDict(realRow)\n            self.signalMyDataChanged.emit(columnName, value, emitRowDict)\n\n            return True\n\n    #\n    return QtCore.QVariant()\n</code></pre>"},{"location":"api/_my_layer/","title":"_my_layer","text":""},{"location":"api/_my_layer/#napari_layer_table._my_layer.labelLayer","title":"<code>labelLayer</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>class labelLayer(QtCore.QObject):\n\n    # Note: these have to be kept in sync with mmLayer signals\n    signalDataChanged = QtCore.Signal(object, object, object, pd.DataFrame)\n    # action'\n    # selected set\n    # selected data : not used\n    # selected df\n\n    signalLayerNameChange = QtCore.Signal(str)\n\n    def __init__(self, viewer, layer,\n                        onAddCallback=None,\n                        onDeleteCallback=None,):\n        \"\"\"\n        Args:\n            onAddCallback: not implemented\n            onDeleteCallback: not implemented\n        \"\"\"\n        #super().__init__(viewer, layer)\n        super().__init__()\n\n        self._viewer = viewer\n        self._layer = layer\n\n        # for label layer, this is an integer (not a set)\n        self._selected_label = self._layer.selected_label\n\n        # just show one selected label (hide all others)\n        #self._layer.show_selected_label = True\n\n        self._connectLayer()\n\n    def bringToFront(self):\n        if self._viewer.layers.selection.active != self._layer:\n            self._viewer.layers.selection.active = self._layer\n\n    def getName(self):\n        return self._layer.name\n\n    def _copy_data(self):\n        logger.info('labelLayer NOT IMPLEMENTED')\n\n    def slot_selected_label(self, event):\n        \"\"\"Respond to user setting label in viewer.\n        \"\"\"\n        logger.info('labelLayer')\n        selected_label = self._layer.selected_label # int\n\n        if selected_label == self._selected_label:\n            print('  no new label selection')\n            return\n\n        self._selected_label = selected_label\n        print('  _selected_label:', self._selected_label)\n\n        #properties = self.getDataFrame()\n\n        #print('  properties:')\n        #pprint(properties)\n\n        '''\n        print('  event.source', event.source)  # same as self._layer\n        print('  event.type', event.type)\n        print('  selected_label:', self._layer.selected_label)\n        print('  event.source.selected_label:', event.source.selected_label)\n        '''\n\n        self._selected_label = event.source._selected_label  # int\n\n        properties = self.getDataFrame()\n        print('  --&gt;&gt; emit \"select\"')\n        # in label layer we will only every select one label\n        # signal/slot expects a list\n        selectedLabelList = [self._selected_label]\n        emptyDict = dict()\n        self.signalDataChanged.emit('select', selectedLabelList, emptyDict, properties)\n\n        #_vars = vars(event)\n        #pprint(_vars)\n\n    def getDataFrame_all(self) -&gt; pd.DataFrame:\n        # TODO (cudmore) this does not work !!!\n        logger.info('label layer')\n        return self.getDataFrame(getFull=True)\n\n    def getDataFrame(self, getFull=False) -&gt; pd.DataFrame:\n        # self._layer.features gives us a (features, properties) pandas dataframe !!!\n\n        logger.info(f'label layer getFull:{getFull}')\n\n        dfFeatures = self._layer.features  # all features\n\n        if getFull:\n            #selectedList = range(len(self._layer.data))\n            # TODO (cudmore) consider keeeping track of this as a member _numLabels\n            selectedList = np.unique(self._layer.data).tolist()  # list\n        else:\n            selectedList = [self._selected_label]  # int\n\n        # label index is 1 based, add one to list\n        # TODO (cudmore) our data model does not work with row labels 1,2,3,...\n        #  it s expecting row index 0 to be preesent\n        #  need to switch over all .iLoc[] to .loc[] or similar\n        '''\n        if selectedList:\n            selectedList = selectedList[0:-1]\n            selectedList = [index+1 for index in selectedList]\n        '''\n        # drop 0 from list\n        zeroIndex = selectedList.index(0)\n        if zeroIndex is not None:\n            logger.info('removing 0 from list, label layer starts at 1')\n            del selectedList[zeroIndex]\n\n        #print('  selectedList:', selectedList)\n        #print('  dfFeatures:')\n        #pprint(dfFeatures)\n\n        if len(dfFeatures) == 0:\n            dfFeatures = pd.DataFrame(index=selectedList)\n\n        # reduce by selection\n        df = dfFeatures.loc[selectedList]\n\n        df.loc[selectedList, \"label\"] = selectedList\n\n        # TODO (cudmore) add z/y/x as mean of pixels in label\n\n        # TODO (cudmore add color with layer get_color(idx) as 'Face Color'\n        colorList_rgba = [self._layer.get_color(index)\n                        for index in selectedList]\n\n        if selectedList:\n            colorList_rgba[0] = (1., 1., 1., 1.)  # index 0 is not actually a label (it selects all)\n        # use str(rgb_to_hex(oneColor)[0])\n        colorList_hex = [str(rgb_to_hex(oneColor)[0])\n                        for oneColor in colorList_rgba]\n\n        #print('  colorList_hex:', colorList_hex)\n        df.loc[selectedList, \"Face Color\"] = colorList_hex\n\n        # abb cudmore baltimore, adding region props to table\n        # Note: region props does not return row 0\n        _properties = ['label', 'centroid', 'area']  # 'solidity' gives convex-hull error\n        props_dict = regionprops_table(self._layer.data, properties=_properties)\n        dfProps = pd.DataFrame(props_dict)\n        # rename some columns\n        dfProps = dfProps.rename(columns={'centroid-0': 'z', 'centroid-1': 'y', 'centroid-2': 'z'})\n\n        #print('df:')\n        #pprint(df)\n\n        return df\n\n    def slot_user_edit_name(self, event):\n        logger.info('')\n        #newName = self._layer.name\n        newName = event.source.name\n        self.signalLayerNameChange.emit(newName)\n\n    def _connectLayer(self, layer=None):\n        self._layer.events.name.connect(self.slot_user_edit_name)\n        self._layer.events.selected_label.connect(self.slot_selected_label)\n\n\n    def selectItems(self, selectedRowSet : set):\n        \"\"\"Set the selected items in layer.\n\n        Called from _my_widget on user selectnig row(s) in table\n        \"\"\"\n        #self._layer.selected_data = selectedRowSet\n        selectedRowList = list(selectedRowSet)\n        if selectedRowList:\n            selectedRow = selectedRowList[0]\n            logger.info(f'labelLayer selectedRow: {selectedRow}')\n            self._layer.selected_label = selectedRow\n\n    def snapToItem(self, selectedRow : int, isAlt : bool =False):\n        pass\n\n    def doUndo(self):\n        #self._undo.doUndo()\n        pass\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.labelLayer.__init__","title":"<code>__init__(viewer, layer, onAddCallback=None, onDeleteCallback=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>onAddCallback</code> <p>not implemented</p> <code>None</code> <code>onDeleteCallback</code> <p>not implemented</p> <code>None</code> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def __init__(self, viewer, layer,\n                    onAddCallback=None,\n                    onDeleteCallback=None,):\n    \"\"\"\n    Args:\n        onAddCallback: not implemented\n        onDeleteCallback: not implemented\n    \"\"\"\n    #super().__init__(viewer, layer)\n    super().__init__()\n\n    self._viewer = viewer\n    self._layer = layer\n\n    # for label layer, this is an integer (not a set)\n    self._selected_label = self._layer.selected_label\n\n    # just show one selected label (hide all others)\n    #self._layer.show_selected_label = True\n\n    self._connectLayer()\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.labelLayer.selectItems","title":"<code>selectItems(selectedRowSet)</code>","text":"<p>Set the selected items in layer.</p> <p>Called from _my_widget on user selectnig row(s) in table</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def selectItems(self, selectedRowSet : set):\n    \"\"\"Set the selected items in layer.\n\n    Called from _my_widget on user selectnig row(s) in table\n    \"\"\"\n    #self._layer.selected_data = selectedRowSet\n    selectedRowList = list(selectedRowSet)\n    if selectedRowList:\n        selectedRow = selectedRowList[0]\n        logger.info(f'labelLayer selectedRow: {selectedRow}')\n        self._layer.selected_label = selectedRow\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.labelLayer.slot_selected_label","title":"<code>slot_selected_label(event)</code>","text":"<p>Respond to user setting label in viewer.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def slot_selected_label(self, event):\n    \"\"\"Respond to user setting label in viewer.\n    \"\"\"\n    logger.info('labelLayer')\n    selected_label = self._layer.selected_label # int\n\n    if selected_label == self._selected_label:\n        print('  no new label selection')\n        return\n\n    self._selected_label = selected_label\n    print('  _selected_label:', self._selected_label)\n\n    #properties = self.getDataFrame()\n\n    #print('  properties:')\n    #pprint(properties)\n\n    '''\n    print('  event.source', event.source)  # same as self._layer\n    print('  event.type', event.type)\n    print('  selected_label:', self._layer.selected_label)\n    print('  event.source.selected_label:', event.source.selected_label)\n    '''\n\n    self._selected_label = event.source._selected_label  # int\n\n    properties = self.getDataFrame()\n    print('  --&gt;&gt; emit \"select\"')\n    # in label layer we will only every select one label\n    # signal/slot expects a list\n    selectedLabelList = [self._selected_label]\n    emptyDict = dict()\n    self.signalDataChanged.emit('select', selectedLabelList, emptyDict, properties)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer","title":"<code>mmLayer</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>class mmLayer(QtCore.QObject):\n    # Note: these have to be kept in sync with labelLayer signals\n    signalDataChanged = QtCore.Signal(str,  # action\n                            set,            # selected set\n                            dict,           # _layerSelectionCopy\n                            pd.DataFrame)   # properties DataFrame\n\n    signalLayerNameChange = QtCore.Signal(str)\n\n    def __init__(self, viewer, layer,\n                    onAddCallback=None,\n                    onDeleteCallback=None,\n                    ):\n        \"\"\"\n        Args:\n            onAddCallback (func) params(set, pd.DataFrame) return Union[None, dict]\n        \"\"\"\n        super().__init__()\n\n        self._viewer = viewer\n        self._layer = layer\n\n        self._shift_click_for_new = False\n        self._onAddCallback = onAddCallback  # callback to accept/reject/modify add\n        self.newOnShiftClick(onAddCallback is not None)\n\n        # not sure how to use bind_key\n        self._deleteOnDeleteKey = False\n        self._onDeleteCallback = onDeleteCallback  # callback to accept/reject/modify add\n        self.deleteOnDeleteKey(onDeleteCallback is not None)\n        #self._layer.bind_key(self.xxx)\n\n        self._flashTimer = None\n        # flash on point selection\n\n        self._undo = None  # creat undo object in derived classes\n\n        self._onlyOneLayer = True\n\n        self._blockOnAdd = False\n\n        self._layerSelectionCopy = None  # a copy of all selected layer data\n\n        self._selected_data = layer.selected_data.copy()\n\n        # replaced by full copy of table in _layerSelectionCopy\n        '''if list(self._selected_data):\n            self._selected_data2 = layer.data[self._selected_data]\n        else:\n            # TODO (cudmore) can we initialize with None ???\n            self._selected_data2 = np.ndarray([])\n        '''\n\n        self._numItems = len(layer.data)\n\n        self._connectLayer()\n\n        # slots to detect a change in layer selection\n        self._viewer.layers.events.inserting.connect(self.slot_insert_layer)\n        self._viewer.layers.events.inserted.connect(self.slot_insert_layer)\n        self._viewer.layers.events.removed.connect(self.slot_remove_layer)\n        self._viewer.layers.events.removing.connect(self.slot_remove_layer)\n\n        self._viewer.layers.selection.events.changed.connect(self.slot_select_layer)\n\n        # todo (cudmore) for now, experiment with this in the mmPoints layer\n        #self._undo = mmUndo(self)  # undo connect to self.signalDataChanged\n\n    '''\n    def keyPressEvent(self, event):\n        logger.info('')\n        if event.key() == QtCore.Qt.Key_Q:\n            pass\n        elif event.key() == QtCore.Qt.Key_Enter:\n            pass\n        event.accept()\n    '''\n\n    @property\n    def properties(self):\n        return self._layer.properties\n\n    def old_on_delete_key_callback(self):\n        \"\"\"Intercept del keystroke and decide if we really want to delete.\n\n        Notes:\n            not implemented.\n        \"\"\"\n        logger.info('')\n\n    def _copy_data(self):\n        \"\"\"Make a complete copy of a layer selection.\n\n        Implement in derived classes.\n        \"\"\"\n        pass\n\n    def doUndo(self):\n        if self._undo is not None:\n            self._undo.doUndo()\n\n    def addFeature(self, featureName : str, columnName : Union[str, None] = None):\n        \"\"\"Add a feature to layer.\n\n        Args:\n            featureName: The key name of the feature to add to layer\n            columnName: Specify if column name in table is different from feature name.\n\n        Notes:\n            We don't want our features (like 'x') to contaminate\n            an existing layer features. User may already have a feature 'x'\n            we don't want to over-wrte it.\n\n            Thus, use\n                featureName = 'ltp_x'\n                columnName = 'x'\n        \"\"\"\n        if columnName is None:\n            columnName = featureName\n        features = self._layer.features # get existing\n        # check if column exists\n        if featureName in features.columns:\n            logger.warning('Feature already exists')\n            return\n        features[featureName] = None  # need to be len(layer)\n\n    def snapToItem(self, selectedRow : int, isAlt : bool =False):\n        \"\"\"Visually snap the viewer to selected item.\n        \"\"\"\n        pass\n\n    def bringToFront(self):\n        \"\"\"Bring the underlying layer to the front.\n        \"\"\"\n        if self._viewer.layers.selection.active != self._layer:\n            self._viewer.layers.selection.active = self._layer\n\n    def getName(self):\n        \"\"\"Get the name from underlying layer.\n        \"\"\"\n        return self._layer.name\n\n    def numItems(self):\n        \"\"\"Get the current number of items.\n\n        Used to determine if we have add/delete in slot_user_edit_highlight().\n        \"\"\"\n        return self._numItems\n\n    def selectItems(self, selectedRowSet : set):\n        \"\"\"Set the selected items in layer.\n\n        Called from _my_widget on user selectnig row(s) in table\n\n        TODO:\n            not used.\n        \"\"\"\n        self._layer.selected_data = selectedRowSet\n\n    @property\n    def selected_data(self):\n        return self._selected_data\n\n    def _connectLayer(self, layer=None):\n\n        self._layer.events.name.connect(self.slot_user_edit_name)\n        self._layer.events.highlight.connect(self.slot_user_edit_highlight)\n        self._layer.events.data.connect(self.slot_user_edit_data)\n\n        # no longer available in PyPi napari\n        # self._layer.events.features.connect(self.slot_user_edit_features)\n\n        # we want to receive an event when user sets the face color of (points, shapes)\n        # this does not trigger?\n        self._layer.events.face_color.connect(self.slot_user_edit_face_color)\n        # this triggers but only for points layer\n        #self._layer._face.events.current_color.connect(self.slot_user_edit_face_color)\n\n        # want to use this, only triggers for shapes layer\n        #self._layer.events.current_face_color.connect(self.slot_user_edit_face_color)\n\n        # this is never called, not sure if it even triggers\n        self._layer.events.properties.connect(self.slot_user_edit_properties)\n\n    def newOnShiftClick(self, on = None):\n        \"\"\"Enable/disable shift+click for new points.\n        \"\"\"\n        if on is not None:\n            self._shift_click_for_new = on\n\n        if self._shift_click_for_new:\n            logger.info(f'{self._derivedClassName()} enabling newOnShiftClick')\n            self._layer.mouse_drag_callbacks.append(self._on_mouse_drag)\n        else:\n            try:\n                logger.info(f'{self._derivedClassName()} disabling newOnShiftClick')\n                self._layer.mouse_drag_callbacks.remove(self._on_mouse_drag)\n            except (ValueError) as e:\n                # not in list\n                pass\n\n    def deleteOnDeleteKey(self, on = None):\n        self._deleteOnDeleteKey = on\n\n    def _on_mouse_drag(self, layer, event):\n        \"\"\"Handle user mouse-clicks. Intercept shift+click to make a new point.\n\n        Will only be called when install with newOnShiftClick().\n        \"\"\"\n        if 'Shift' in event.modifiers:\n            # make a new point at cursor position\n            onAddReturn = {}\n            if self._onAddCallback is not None:\n                logger.info(f'checking with _onAddCallback ...')\n                # onAddCallback should determine (i) if we want to actually add\n                # (ii) if add is ok, return a dict of values for selected row\n                onAddReturn = self._onAddCallback(self._selected_data, self.getDataFrame())\n                if onAddReturn is None:\n                    print('    shift+clik was rejected --&gt;&gt; no new point')\n                    return\n                else:\n                    print('  on add return returned dict:')\n                    pprint(onAddReturn)\n\n            data_coordinates = self._layer.world_to_data(event.position)\n            # always add as integer pixels (not fractional/float pixels)\n            cords = np.round(data_coordinates).astype(int)\n\n            # add to layer, only for points layer?\n            # for shape layer type 'path', use add_paths()\n            # self._layer.add(cords)\n            self.addAnnotation(cords, event, features=onAddReturn)\n\n            # set features from onAddReturn\n\n    '''\n    def on_mouse_wheel(self, layer, event):\n        \"\"\"Mouse wheel callback.\n\n        Over-ride default behavior to become\n\n            mouse-wheel: scroll through image planes (need a 3d image)\n            mouse-wheel + ctrl: zoom in/out on mouse position\n        \"\"\"        \n        # used to find what data the event has\n        pprint(vars(event))\n\n        isShift = 'Shift' in event.modifiers\n        isControl = 'Control' in event.modifiers\n\n        #xDelta = event.delta[0]  # ignore\n        yDelta = event.delta[1]  # +1 is 'up', -1 is 'down'\n\n        logger.info(f'handled:{event.handled} isShift:{isShift} isControl:{isControl} yDelta:{yDelta}')\n\n        #self.dims._increment_dims_left()\n        if isControl:            \n            zoomScale = 0.1\n            _start_zoom = self._viewer.camera.zoom\n            self._viewer.camera.zoom = _start_zoom * (zoomScale + yDelta)\n            #event.handled = True\n    '''\n\n    def addAnnotation(self, coords, event = None, features:dict = None):\n        \"\"\"Add an annotation to a layer.\n\n        Define when deriving. For points layer use 'self._layer.add(cords)'\n\n        Args:\n            coords:\n            event: napari mouse down event\n        \"\"\"\n        pass\n\n    def getDataFrame(self, getFull=False) -&gt; pd.DataFrame:\n        \"\"\"Get a dataframe from layer.\n\n        Args:\n            getFull: get full dataframe\n                otherwise, get datafram for _selectedData\n        \"\"\"\n\n        # self._layer.features gives us a (features, properties) pandas dataframe !!!        \n        # can be empty !!!\n        dfFeatures = self._layer.features  # all features\n\n        # not neccessary, alreay a pd.DataFrame (I think)\n        # dfFeatures = features_to_pandas_dataframe(dfFeatures)\n\n        if getFull:\n            selectedList = list(range(len(self._layer.data)))\n        else:\n            selectedList = list(self._selected_data)\n\n        # reduce by selection\n        df = dfFeatures.loc[selectedList]\n\n        if len(df) == 0:\n            df = pd.DataFrame(index=selectedList)\n\n        #\n        # This is impossibly hard to get working\n        # I just want to assign a column named 'Face Color'\n        # Bottom line, all cells in a pd.DataFrame need to be scalars\n        # TODO (cudmore) use hex values rather than rgba\n\n        # SettingWithCopyWarning\n        # A value is trying to be set on a copy of a slice from a DataFrame.\n        # Try using .loc[row_indexer,col_indexer] = value instead\n        #print('=== SettingWithCopyWarning:', self._derivedClassName())\n        #print('selectedList:', selectedList)\n        #pprint(df)\n        # ValueError: cannot set a frame with no defined index and a scalar\n        # df.loc[selectedList, 'Face Color'] = ''\n\n\n        if selectedList:\n            # TODO (cudmore) rgb_to_hex() returns an np.array with  dtype of unicode '|U9''\n            #    we want it as a string ???\n            tmpColor = [str(rgb_to_hex(oneColor)[0])\n                        for oneColor in self._layer.face_color[selectedList]]        \n\n            df.loc[selectedList, 'Face Color'] = tmpColor\n\n        return df\n\n    def _derivedClassName(self):\n        return self.__class__.__name__\n\n    def slot_user_edit_highlight(self, event):\n        \"\"\"Called repeatedly on mouse hover.\n\n        Error:\n            mm_env/lib/python3.9/site-packages/numpy/core/fromnumeric.py:43:\n            VisibleDeprecationWarning:\n            Creating an ndarray from ragged nested sequences\n            (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes)\n            is deprecated.\n            If you meant to do this, you must specify 'dtype=object' when creating the ndarray.!\n\n        \"\"\"\n        newSelection = not setsAreEqual(event.source.selected_data, self._selected_data)\n\n        action = 'none'\n        if len(event.source.data) &gt; self.numItems():\n            # add an item: for points layer is point, for shapes layer is shape\n            # event.source.selected_data gives us the added points\n            # for shape layer, *this is called multiple times without the added items selected\n            if newSelection:\n                action = 'add'\n            else:\n                # this happens on add in shapes layer\n                # for shapes, need to add\n                print('    ==== data length changed but selection did not...')\n                print('     event.source.selected_data:', event.source.selected_data)\n                print('     self._selected_data:', self._selected_data)\n                '''\n                _newSelectionStart = self.numItems()\n                _newSelectionStop = len(event.source.data)\n                _newSelectionRange = np.arange(_newSelectionStart, _newSelectionStop)\n                event.source.selected_data = set(_newSelectionRange)\n                print(f'     tweeked event.source.selected_data: {event.source.selected_data}')\n                action = 'add'\n                '''\n        elif len(event.source.data) &lt; self.numItems():\n            # event.source.selected_data tells us the rows\n            # THEY NO LONGER EXIST\n            # our current self._selected_data tells us the rows\n            action = 'delete'\n        elif newSelection:\n            action = 'select'\n\n        '''\n        if newSelection and self._blockOnAdd and not event.source.selected_data:\n            # after shapes add, we re-enter here but event.source.selected_data is empty set()\n            # should be the newly added shape(s), e.g. self._selected_data\n            print('        ================')\n            print('        action:', action)\n            print('        convert to action: select')\n            event.source.selected_data = self._selected_data\n            self._blockOnAdd = False\n        '''\n\n        if action != 'none':\n            logger.info(f'{self._derivedClassName()}')\n            print('    newSelection:', newSelection)\n            print('    event.source.selected_data:', event.source.selected_data)\n            print('    self._selected_data:', self._selected_data)\n            print('    len(event.source.data):', len(event.source.data))\n            print('    self.numItems():', self.numItems())\n            print('    action:', action)\n\n        # signal what changed\n        if action == 'add':\n            # for shapes layer, when we get called again selected_data == set()\n            self._blockOnAdd = True\n\n            # on add we have new items and they are selected\n            self._selected_data = event.source.selected_data.copy()\n            self._numItems = len(event.source.data)\n\n            # trying to figure out shapes layer\n            # after add shapes layer trigger selection with set(), not with what was added\n            #if not self._selected_data:\n            #    print(f'    ERROR in {self._derivedClassName()} ... new shapes are not selected')\n            _selected_data_set = set(self._selected_data)  # abb 202402\n            self._copy_data()  # copy all selected points to _layerSelectionCopy\n            self._updateFeatures(self._selected_data)\n            dfFeatures = self.getDataFrame()\n            print(f'  --&gt;&gt; signalDataChanged.emit \"add\" with _selected_data:{self._selected_data}')\n            self.signalDataChanged.emit('add',\n                                _selected_data_set,\n                                # self._selected_data,\n                                self._layerSelectionCopy,\n                                dfFeatures)\n\n        elif action == 'delete':\n            # on delete, data indices were deleted_selected_data\n            delete_selected_data = self._selected_data.copy()\n            delete_selected_data_set = set(delete_selected_data)  # abb 202402\n            self._selected_data = set()\n            self._numItems = len(event.source.data)\n\n            # here we are reusing previous _layerSelectionCopy\n            # from action ('add', 'select')\n            logger.info(f'  --&gt;&gt; signalDataChanged.emit \"delete\" with delete_selected_data:{delete_selected_data}')\n            self.signalDataChanged.emit('delete',\n                            delete_selected_data_set,  # abb 202402\n                            # delete_selected_data,\n                            self._layerSelectionCopy,\n                            pd.DataFrame())\n\n        elif action == 'select':\n            self._selected_data = event.source.selected_data.copy()\n\n            selectedDataSet = set(self._selected_data)\n            self._copy_data()  # copy all selected points to _layerSelectionCopy\n            dfProperties = self.getDataFrame()\n\n            logger.info(f'action:{action}')\n            print(f'  --&gt;&gt; signalDataChanged.emit \"select\" with _selected_data:{self._selected_data}')\n            pprint(dfProperties)\n            print('')\n            self.signalDataChanged.emit('select',\n                                selectedDataSet,  # abb 202402\n                                # self._selected_data,\n                                self._layerSelectionCopy,\n                                dfProperties)\n\n    def slot_user_edit_data(self, event):\n        \"\"\"User edited a point in the current layer.\n\n        This is generated when user finishes a click+drag.\n\n        Notes:\n            On key-press (like delete), we need to ignore event.source.mode\n        \"\"\"\n\n        # if there is no selection, there is never a change\n        # this does not work for shapes layer\n        if not self._selected_data:\n            # no data changes when no selection\n            logger.info(f'NO CHANGE BECAUSE _selected_data is (empty) {self._selected_data}')\n            return\n\n        # we usually show x/y/z in table\n        # update our internal fatures\n        self._updateFeatures(self._selected_data)\n\n        # copy the selection\n        self._copy_data()\n\n        dfFeatures = self.getDataFrame()\n\n        logger.info('')\n        logger.info(f'  --&gt;&gt; signalDataChanged.emit \"change\" with _selected_data:{self._selected_data}')\n        logger.info('    features:')\n        pprint(dfFeatures)\n\n        selectedDataSet = set(self._selected_data)\n        self.signalDataChanged.emit('change', \n                        selectedDataSet,  # abb 202402\n                        # self._selected_data, \n                        self._layerSelectionCopy, \n                        dfFeatures)\n\n    def slot_user_edit_face_color(self, event):\n        \"\"\"User selected a face color.\n\n        Change the face color of selected points.\n\n        Note:\n            - Using hex #RRGGBBAA\n            - QColor takes #AARRGGBB, see _data_model.data (QtCore.Qt.ForegroundRole)\n        \"\"\"\n        layer = self._viewer.layers.selection.active  # can be None\n        try:\n            print('        layer selected_data:', layer.selected_data)\n            print('        self.selected_data:', self._selected_data)\n            if not setsAreEqual(layer.selected_data, self._selected_data):\n                logger.warning('ignoring event: selected_data do not match')\n                return\n        except (AttributeError) as e:\n            logger.warning(e)\n            return\n\n        if self._selected_data:\n\n            current_face_color = self._layer.current_face_color  # hex\n\n            logger.info(f'current_face_color:{current_face_color}')\n\n            dfProperties = self.getDataFrame()\n\n            index = list(self._selected_data)\n            dfProperties.loc[index, 'Face Color'] = current_face_color\n\n            #for oneRowIndex in index:\n            #    properties.loc[oneRowIndex, 'Face Color'] = current_face_color\n\n            # copy selected data, not sure this is needed, updates _layerSelectionCopy\n            self._copy_data()\n\n            print('  --&gt;&gt; emit \"change\"')\n            print('        self._selected_data:', self._selected_data)\n            print('        dfProperties:')\n            pprint(dfProperties)\n\n            #pprint(vars(event))\n            #print('\\n\\n')\n            _selected_data_set = set(self._selected_data)\n            self.signalDataChanged.emit('change',\n                            _selected_data_set,\n                            # self._selected_data,\n                            self._layerSelectionCopy,\n                            dfProperties)\n\n    def slot_user_edit_name(self, event):\n        print('slot_user_edit_name()')\n        #newName = self._layer.name\n        newName = event.source.name\n        self.signalLayerNameChange.emit(newName)\n\n    def slot_user_edit_properties(self, event):\n        logger.info('')\n\n    def slot_user_edit_features(self, event):\n        logger.info('')\n\n    def slot_select_layer(self, event):\n        \"\"\"Respond to layer selection in viewer.\n\n        Args:\n            event (Event): event.type == 'changed'\n        \"\"\"\n        #logger.info(f'event.type: {event.type}')\n\n        if self._onlyOneLayer:\n            return\n\n        # BUG: does not give the correct layer\n        # Need to query global viewer. Is selected layer in event???\n        #layer = event.source\n        layer = self._viewer.layers.selection.active\n\n        #if layer is not None:\n        #    if layer != self._layer:\n        #        self.connectLayer(layer)\n        if layer != self._layer:\n            self._connectLayer(layer)\n\n    def slot_insert_layer(self, event):\n        \"\"\"Respond to new layer in viewer.\n        \"\"\"\n\n        if self._onlyOneLayer:\n            return\n\n        if event.type == 'inserting':\n            pass\n        elif event.type == 'inserted':\n            logger.info(f'New layer \"{event.value}\" was inserted at index {event.index}')\n\n            layer = event.value\n            self._connectLayer(layer)\n\n    def slot_remove_layer(self, event):\n        \"\"\"Respond to layer delete in viewer.\n        \"\"\"\n\n        if self._onlyOneLayer:\n            return\n\n        if event.type == 'removing':\n            pass\n        elif event.type == 'removed':\n            logger.info(f'Removed layer \"{event.value}\"')\n\n            # table data is empty\n            #self.refreshTableData([])\n\n            # TODO: does not work, newSelectedLayer is always None\n            # we are not receiving new layer selection\n            # do it manually from current state of the viewer\n            newSelectedLayer = self._viewer.layers.selection.active\n            self._connectLayer(newSelectedLayer)\n\n    def printEvent(self, event):\n        \"\"\"Print all info on an event.\n\n        TODO (cudmore) Not used.\n        \"\"\"\n        print(f'    _printEvent() type:{type(event)}')\n        print(f'    event.type: {event.type}')\n        print(f'    event.source: {event.source} {type(event.source)}')\n        print(f'    event.source.name: \"{event.source.name}\"')        \n        print(f'    event.source.mode: {event.source.mode}')        \n        print(f'    event.source.selected_data: {event.source.selected_data}')\n\n        # data is either a list or an ndarray\n        print(f'    type(event.source.data): {type(event.source.data)}')\n        print(f'    len(event.source.data): {len(event.source.data)}')\n\n        print(f'    event.source.data: {event.source.data}')\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.__init__","title":"<code>__init__(viewer, layer, onAddCallback=None, onDeleteCallback=None)</code>","text":"Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def __init__(self, viewer, layer,\n                onAddCallback=None,\n                onDeleteCallback=None,\n                ):\n    \"\"\"\n    Args:\n        onAddCallback (func) params(set, pd.DataFrame) return Union[None, dict]\n    \"\"\"\n    super().__init__()\n\n    self._viewer = viewer\n    self._layer = layer\n\n    self._shift_click_for_new = False\n    self._onAddCallback = onAddCallback  # callback to accept/reject/modify add\n    self.newOnShiftClick(onAddCallback is not None)\n\n    # not sure how to use bind_key\n    self._deleteOnDeleteKey = False\n    self._onDeleteCallback = onDeleteCallback  # callback to accept/reject/modify add\n    self.deleteOnDeleteKey(onDeleteCallback is not None)\n    #self._layer.bind_key(self.xxx)\n\n    self._flashTimer = None\n    # flash on point selection\n\n    self._undo = None  # creat undo object in derived classes\n\n    self._onlyOneLayer = True\n\n    self._blockOnAdd = False\n\n    self._layerSelectionCopy = None  # a copy of all selected layer data\n\n    self._selected_data = layer.selected_data.copy()\n\n    # replaced by full copy of table in _layerSelectionCopy\n    '''if list(self._selected_data):\n        self._selected_data2 = layer.data[self._selected_data]\n    else:\n        # TODO (cudmore) can we initialize with None ???\n        self._selected_data2 = np.ndarray([])\n    '''\n\n    self._numItems = len(layer.data)\n\n    self._connectLayer()\n\n    # slots to detect a change in layer selection\n    self._viewer.layers.events.inserting.connect(self.slot_insert_layer)\n    self._viewer.layers.events.inserted.connect(self.slot_insert_layer)\n    self._viewer.layers.events.removed.connect(self.slot_remove_layer)\n    self._viewer.layers.events.removing.connect(self.slot_remove_layer)\n\n    self._viewer.layers.selection.events.changed.connect(self.slot_select_layer)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.addAnnotation","title":"<code>addAnnotation(coords, event=None, features=None)</code>","text":"<p>Add an annotation to a layer.</p> <p>Define when deriving. For points layer use 'self._layer.add(cords)'</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> required <code>event</code> <p>napari mouse down event</p> <code>None</code> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def addAnnotation(self, coords, event = None, features:dict = None):\n    \"\"\"Add an annotation to a layer.\n\n    Define when deriving. For points layer use 'self._layer.add(cords)'\n\n    Args:\n        coords:\n        event: napari mouse down event\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.addFeature","title":"<code>addFeature(featureName, columnName=None)</code>","text":"<p>Add a feature to layer.</p> <p>Parameters:</p> Name Type Description Default <code>featureName</code> <code>str</code> <p>The key name of the feature to add to layer</p> required <code>columnName</code> <code>Union[str, None]</code> <p>Specify if column name in table is different from feature name.</p> <code>None</code> Notes <p>We don't want our features (like 'x') to contaminate an existing layer features. User may already have a feature 'x' we don't want to over-wrte it.</p> <p>Thus, use     featureName = 'ltp_x'     columnName = 'x'</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def addFeature(self, featureName : str, columnName : Union[str, None] = None):\n    \"\"\"Add a feature to layer.\n\n    Args:\n        featureName: The key name of the feature to add to layer\n        columnName: Specify if column name in table is different from feature name.\n\n    Notes:\n        We don't want our features (like 'x') to contaminate\n        an existing layer features. User may already have a feature 'x'\n        we don't want to over-wrte it.\n\n        Thus, use\n            featureName = 'ltp_x'\n            columnName = 'x'\n    \"\"\"\n    if columnName is None:\n        columnName = featureName\n    features = self._layer.features # get existing\n    # check if column exists\n    if featureName in features.columns:\n        logger.warning('Feature already exists')\n        return\n    features[featureName] = None  # need to be len(layer)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.bringToFront","title":"<code>bringToFront()</code>","text":"<p>Bring the underlying layer to the front.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def bringToFront(self):\n    \"\"\"Bring the underlying layer to the front.\n    \"\"\"\n    if self._viewer.layers.selection.active != self._layer:\n        self._viewer.layers.selection.active = self._layer\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.getDataFrame","title":"<code>getDataFrame(getFull=False)</code>","text":"<p>Get a dataframe from layer.</p> <p>Parameters:</p> Name Type Description Default <code>getFull</code> <p>get full dataframe otherwise, get datafram for _selectedData</p> <code>False</code> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def getDataFrame(self, getFull=False) -&gt; pd.DataFrame:\n    \"\"\"Get a dataframe from layer.\n\n    Args:\n        getFull: get full dataframe\n            otherwise, get datafram for _selectedData\n    \"\"\"\n\n    # self._layer.features gives us a (features, properties) pandas dataframe !!!        \n    # can be empty !!!\n    dfFeatures = self._layer.features  # all features\n\n    # not neccessary, alreay a pd.DataFrame (I think)\n    # dfFeatures = features_to_pandas_dataframe(dfFeatures)\n\n    if getFull:\n        selectedList = list(range(len(self._layer.data)))\n    else:\n        selectedList = list(self._selected_data)\n\n    # reduce by selection\n    df = dfFeatures.loc[selectedList]\n\n    if len(df) == 0:\n        df = pd.DataFrame(index=selectedList)\n\n    #\n    # This is impossibly hard to get working\n    # I just want to assign a column named 'Face Color'\n    # Bottom line, all cells in a pd.DataFrame need to be scalars\n    # TODO (cudmore) use hex values rather than rgba\n\n    # SettingWithCopyWarning\n    # A value is trying to be set on a copy of a slice from a DataFrame.\n    # Try using .loc[row_indexer,col_indexer] = value instead\n    #print('=== SettingWithCopyWarning:', self._derivedClassName())\n    #print('selectedList:', selectedList)\n    #pprint(df)\n    # ValueError: cannot set a frame with no defined index and a scalar\n    # df.loc[selectedList, 'Face Color'] = ''\n\n\n    if selectedList:\n        # TODO (cudmore) rgb_to_hex() returns an np.array with  dtype of unicode '|U9''\n        #    we want it as a string ???\n        tmpColor = [str(rgb_to_hex(oneColor)[0])\n                    for oneColor in self._layer.face_color[selectedList]]        \n\n        df.loc[selectedList, 'Face Color'] = tmpColor\n\n    return df\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.getName","title":"<code>getName()</code>","text":"<p>Get the name from underlying layer.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def getName(self):\n    \"\"\"Get the name from underlying layer.\n    \"\"\"\n    return self._layer.name\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.newOnShiftClick","title":"<code>newOnShiftClick(on=None)</code>","text":"<p>Enable/disable shift+click for new points.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def newOnShiftClick(self, on = None):\n    \"\"\"Enable/disable shift+click for new points.\n    \"\"\"\n    if on is not None:\n        self._shift_click_for_new = on\n\n    if self._shift_click_for_new:\n        logger.info(f'{self._derivedClassName()} enabling newOnShiftClick')\n        self._layer.mouse_drag_callbacks.append(self._on_mouse_drag)\n    else:\n        try:\n            logger.info(f'{self._derivedClassName()} disabling newOnShiftClick')\n            self._layer.mouse_drag_callbacks.remove(self._on_mouse_drag)\n        except (ValueError) as e:\n            # not in list\n            pass\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.numItems","title":"<code>numItems()</code>","text":"<p>Get the current number of items.</p> <p>Used to determine if we have add/delete in slot_user_edit_highlight().</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def numItems(self):\n    \"\"\"Get the current number of items.\n\n    Used to determine if we have add/delete in slot_user_edit_highlight().\n    \"\"\"\n    return self._numItems\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.old_on_delete_key_callback","title":"<code>old_on_delete_key_callback()</code>","text":"<p>Intercept del keystroke and decide if we really want to delete.</p> Notes <p>not implemented.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def old_on_delete_key_callback(self):\n    \"\"\"Intercept del keystroke and decide if we really want to delete.\n\n    Notes:\n        not implemented.\n    \"\"\"\n    logger.info('')\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.printEvent","title":"<code>printEvent(event)</code>","text":"<p>Print all info on an event.</p> <p>TODO (cudmore) Not used.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def printEvent(self, event):\n    \"\"\"Print all info on an event.\n\n    TODO (cudmore) Not used.\n    \"\"\"\n    print(f'    _printEvent() type:{type(event)}')\n    print(f'    event.type: {event.type}')\n    print(f'    event.source: {event.source} {type(event.source)}')\n    print(f'    event.source.name: \"{event.source.name}\"')        \n    print(f'    event.source.mode: {event.source.mode}')        \n    print(f'    event.source.selected_data: {event.source.selected_data}')\n\n    # data is either a list or an ndarray\n    print(f'    type(event.source.data): {type(event.source.data)}')\n    print(f'    len(event.source.data): {len(event.source.data)}')\n\n    print(f'    event.source.data: {event.source.data}')\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.selectItems","title":"<code>selectItems(selectedRowSet)</code>","text":"<p>Set the selected items in layer.</p> <p>Called from _my_widget on user selectnig row(s) in table</p> TODO <p>not used.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def selectItems(self, selectedRowSet : set):\n    \"\"\"Set the selected items in layer.\n\n    Called from _my_widget on user selectnig row(s) in table\n\n    TODO:\n        not used.\n    \"\"\"\n    self._layer.selected_data = selectedRowSet\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.slot_insert_layer","title":"<code>slot_insert_layer(event)</code>","text":"<p>Respond to new layer in viewer.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def slot_insert_layer(self, event):\n    \"\"\"Respond to new layer in viewer.\n    \"\"\"\n\n    if self._onlyOneLayer:\n        return\n\n    if event.type == 'inserting':\n        pass\n    elif event.type == 'inserted':\n        logger.info(f'New layer \"{event.value}\" was inserted at index {event.index}')\n\n        layer = event.value\n        self._connectLayer(layer)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.slot_remove_layer","title":"<code>slot_remove_layer(event)</code>","text":"<p>Respond to layer delete in viewer.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def slot_remove_layer(self, event):\n    \"\"\"Respond to layer delete in viewer.\n    \"\"\"\n\n    if self._onlyOneLayer:\n        return\n\n    if event.type == 'removing':\n        pass\n    elif event.type == 'removed':\n        logger.info(f'Removed layer \"{event.value}\"')\n\n        # table data is empty\n        #self.refreshTableData([])\n\n        # TODO: does not work, newSelectedLayer is always None\n        # we are not receiving new layer selection\n        # do it manually from current state of the viewer\n        newSelectedLayer = self._viewer.layers.selection.active\n        self._connectLayer(newSelectedLayer)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.slot_select_layer","title":"<code>slot_select_layer(event)</code>","text":"<p>Respond to layer selection in viewer.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>event.type == 'changed'</p> required Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def slot_select_layer(self, event):\n    \"\"\"Respond to layer selection in viewer.\n\n    Args:\n        event (Event): event.type == 'changed'\n    \"\"\"\n    #logger.info(f'event.type: {event.type}')\n\n    if self._onlyOneLayer:\n        return\n\n    # BUG: does not give the correct layer\n    # Need to query global viewer. Is selected layer in event???\n    #layer = event.source\n    layer = self._viewer.layers.selection.active\n\n    #if layer is not None:\n    #    if layer != self._layer:\n    #        self.connectLayer(layer)\n    if layer != self._layer:\n        self._connectLayer(layer)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.slot_user_edit_data","title":"<code>slot_user_edit_data(event)</code>","text":"<p>User edited a point in the current layer.</p> <p>This is generated when user finishes a click+drag.</p> Notes <p>On key-press (like delete), we need to ignore event.source.mode</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def slot_user_edit_data(self, event):\n    \"\"\"User edited a point in the current layer.\n\n    This is generated when user finishes a click+drag.\n\n    Notes:\n        On key-press (like delete), we need to ignore event.source.mode\n    \"\"\"\n\n    # if there is no selection, there is never a change\n    # this does not work for shapes layer\n    if not self._selected_data:\n        # no data changes when no selection\n        logger.info(f'NO CHANGE BECAUSE _selected_data is (empty) {self._selected_data}')\n        return\n\n    # we usually show x/y/z in table\n    # update our internal fatures\n    self._updateFeatures(self._selected_data)\n\n    # copy the selection\n    self._copy_data()\n\n    dfFeatures = self.getDataFrame()\n\n    logger.info('')\n    logger.info(f'  --&gt;&gt; signalDataChanged.emit \"change\" with _selected_data:{self._selected_data}')\n    logger.info('    features:')\n    pprint(dfFeatures)\n\n    selectedDataSet = set(self._selected_data)\n    self.signalDataChanged.emit('change', \n                    selectedDataSet,  # abb 202402\n                    # self._selected_data, \n                    self._layerSelectionCopy, \n                    dfFeatures)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.slot_user_edit_face_color","title":"<code>slot_user_edit_face_color(event)</code>","text":"<p>User selected a face color.</p> <p>Change the face color of selected points.</p> Note <ul> <li>Using hex #RRGGBBAA</li> <li>QColor takes #AARRGGBB, see _data_model.data (QtCore.Qt.ForegroundRole)</li> </ul> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def slot_user_edit_face_color(self, event):\n    \"\"\"User selected a face color.\n\n    Change the face color of selected points.\n\n    Note:\n        - Using hex #RRGGBBAA\n        - QColor takes #AARRGGBB, see _data_model.data (QtCore.Qt.ForegroundRole)\n    \"\"\"\n    layer = self._viewer.layers.selection.active  # can be None\n    try:\n        print('        layer selected_data:', layer.selected_data)\n        print('        self.selected_data:', self._selected_data)\n        if not setsAreEqual(layer.selected_data, self._selected_data):\n            logger.warning('ignoring event: selected_data do not match')\n            return\n    except (AttributeError) as e:\n        logger.warning(e)\n        return\n\n    if self._selected_data:\n\n        current_face_color = self._layer.current_face_color  # hex\n\n        logger.info(f'current_face_color:{current_face_color}')\n\n        dfProperties = self.getDataFrame()\n\n        index = list(self._selected_data)\n        dfProperties.loc[index, 'Face Color'] = current_face_color\n\n        #for oneRowIndex in index:\n        #    properties.loc[oneRowIndex, 'Face Color'] = current_face_color\n\n        # copy selected data, not sure this is needed, updates _layerSelectionCopy\n        self._copy_data()\n\n        print('  --&gt;&gt; emit \"change\"')\n        print('        self._selected_data:', self._selected_data)\n        print('        dfProperties:')\n        pprint(dfProperties)\n\n        #pprint(vars(event))\n        #print('\\n\\n')\n        _selected_data_set = set(self._selected_data)\n        self.signalDataChanged.emit('change',\n                        _selected_data_set,\n                        # self._selected_data,\n                        self._layerSelectionCopy,\n                        dfProperties)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.slot_user_edit_highlight","title":"<code>slot_user_edit_highlight(event)</code>","text":"<p>Called repeatedly on mouse hover.</p> Error <p>mm_env/lib/python3.9/site-packages/numpy/core/fromnumeric.py:43: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.!</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def slot_user_edit_highlight(self, event):\n    \"\"\"Called repeatedly on mouse hover.\n\n    Error:\n        mm_env/lib/python3.9/site-packages/numpy/core/fromnumeric.py:43:\n        VisibleDeprecationWarning:\n        Creating an ndarray from ragged nested sequences\n        (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes)\n        is deprecated.\n        If you meant to do this, you must specify 'dtype=object' when creating the ndarray.!\n\n    \"\"\"\n    newSelection = not setsAreEqual(event.source.selected_data, self._selected_data)\n\n    action = 'none'\n    if len(event.source.data) &gt; self.numItems():\n        # add an item: for points layer is point, for shapes layer is shape\n        # event.source.selected_data gives us the added points\n        # for shape layer, *this is called multiple times without the added items selected\n        if newSelection:\n            action = 'add'\n        else:\n            # this happens on add in shapes layer\n            # for shapes, need to add\n            print('    ==== data length changed but selection did not...')\n            print('     event.source.selected_data:', event.source.selected_data)\n            print('     self._selected_data:', self._selected_data)\n            '''\n            _newSelectionStart = self.numItems()\n            _newSelectionStop = len(event.source.data)\n            _newSelectionRange = np.arange(_newSelectionStart, _newSelectionStop)\n            event.source.selected_data = set(_newSelectionRange)\n            print(f'     tweeked event.source.selected_data: {event.source.selected_data}')\n            action = 'add'\n            '''\n    elif len(event.source.data) &lt; self.numItems():\n        # event.source.selected_data tells us the rows\n        # THEY NO LONGER EXIST\n        # our current self._selected_data tells us the rows\n        action = 'delete'\n    elif newSelection:\n        action = 'select'\n\n    '''\n    if newSelection and self._blockOnAdd and not event.source.selected_data:\n        # after shapes add, we re-enter here but event.source.selected_data is empty set()\n        # should be the newly added shape(s), e.g. self._selected_data\n        print('        ================')\n        print('        action:', action)\n        print('        convert to action: select')\n        event.source.selected_data = self._selected_data\n        self._blockOnAdd = False\n    '''\n\n    if action != 'none':\n        logger.info(f'{self._derivedClassName()}')\n        print('    newSelection:', newSelection)\n        print('    event.source.selected_data:', event.source.selected_data)\n        print('    self._selected_data:', self._selected_data)\n        print('    len(event.source.data):', len(event.source.data))\n        print('    self.numItems():', self.numItems())\n        print('    action:', action)\n\n    # signal what changed\n    if action == 'add':\n        # for shapes layer, when we get called again selected_data == set()\n        self._blockOnAdd = True\n\n        # on add we have new items and they are selected\n        self._selected_data = event.source.selected_data.copy()\n        self._numItems = len(event.source.data)\n\n        # trying to figure out shapes layer\n        # after add shapes layer trigger selection with set(), not with what was added\n        #if not self._selected_data:\n        #    print(f'    ERROR in {self._derivedClassName()} ... new shapes are not selected')\n        _selected_data_set = set(self._selected_data)  # abb 202402\n        self._copy_data()  # copy all selected points to _layerSelectionCopy\n        self._updateFeatures(self._selected_data)\n        dfFeatures = self.getDataFrame()\n        print(f'  --&gt;&gt; signalDataChanged.emit \"add\" with _selected_data:{self._selected_data}')\n        self.signalDataChanged.emit('add',\n                            _selected_data_set,\n                            # self._selected_data,\n                            self._layerSelectionCopy,\n                            dfFeatures)\n\n    elif action == 'delete':\n        # on delete, data indices were deleted_selected_data\n        delete_selected_data = self._selected_data.copy()\n        delete_selected_data_set = set(delete_selected_data)  # abb 202402\n        self._selected_data = set()\n        self._numItems = len(event.source.data)\n\n        # here we are reusing previous _layerSelectionCopy\n        # from action ('add', 'select')\n        logger.info(f'  --&gt;&gt; signalDataChanged.emit \"delete\" with delete_selected_data:{delete_selected_data}')\n        self.signalDataChanged.emit('delete',\n                        delete_selected_data_set,  # abb 202402\n                        # delete_selected_data,\n                        self._layerSelectionCopy,\n                        pd.DataFrame())\n\n    elif action == 'select':\n        self._selected_data = event.source.selected_data.copy()\n\n        selectedDataSet = set(self._selected_data)\n        self._copy_data()  # copy all selected points to _layerSelectionCopy\n        dfProperties = self.getDataFrame()\n\n        logger.info(f'action:{action}')\n        print(f'  --&gt;&gt; signalDataChanged.emit \"select\" with _selected_data:{self._selected_data}')\n        pprint(dfProperties)\n        print('')\n        self.signalDataChanged.emit('select',\n                            selectedDataSet,  # abb 202402\n                            # self._selected_data,\n                            self._layerSelectionCopy,\n                            dfProperties)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.mmLayer.snapToItem","title":"<code>snapToItem(selectedRow, isAlt=False)</code>","text":"<p>Visually snap the viewer to selected item.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def snapToItem(self, selectedRow : int, isAlt : bool =False):\n    \"\"\"Visually snap the viewer to selected item.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.pointsLayer","title":"<code>pointsLayer</code>","text":"<p>               Bases: <code>mmLayer</code></p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>class pointsLayer(mmLayer):\n    def __init__(self, viewer, layer, *args, **kwargs):\n\n        super().__init__(viewer, layer, *args, **kwargs)\n\n        logger.info('Creating pointsLayer')\n\n        # features this layer will calculate\n        # updated in _updateFeatures\n        # stored in layer features and displayed as columns in table\n        self.addFeature('x')\n        self.addFeature('y')\n        if self._layer.ndim &gt;= 3:\n            self.addFeature('z')\n\n        self._updateFeatures()\n\n        # todo (cudmore) for now, experiment with this in the mmPoints layer\n        #self._undo = mmUndo(self)  # undo connect to self.signalDataChanged\n\n    def _connectLayer(self, layer=None):\n        \"\"\"Connect underlying layer signals to slots.\n        \"\"\"\n        super()._connectLayer()\n\n        # this triggers but only for points layer\n        # was this\n        self._layer._face.events.current_color.connect(self.slot_user_edit_face_color)\n        # this this\n        #self._layer.events.face_color.connect(self.slot_user_edit_face_color)\n        #self._layer.events.current_face_color.connect(self.slot_user_edit_face_color)\n\n        self._layer.events.symbol.connect(self.slot_user_edit_symbol)  # points layer\n        self._layer.events.size.connect(self.slot_user_edit_size)  # points layer\n\n    def _updateFeatures(self, selectedDataSet=None):\n        \"\"\"Update layer features based on selection.\n\n        Used for (i) creation and (ii) on data move.\n\n        Args:\n            selectedDataSet (set) selected data, Pass None to update all.\n        \"\"\"\n        if selectedDataSet is None:\n            selectedDataSet = set(range(self.numItems()))\n\n\n        selectedList = list(selectedDataSet)\n\n        # logger.info(f'check x/y/z order')\n        # print(self._layer.data)\n\n        #TODO: (cudmore) what if points layer has dim &gt; 3 ???\n        if self._layer.ndim == 3:\n            self._layer.features.loc[selectedList, 'z'] = \\\n                            self._layer.data[selectedList,0]\n            self._layer.features.loc[selectedList, 'x'] = \\\n                                self._layer.data[selectedList,2]\n            self._layer.features.loc[selectedList, 'y'] = \\\n                                self._layer.data[selectedList,1]\n        elif self._layer.ndim == 2:\n            self._layer.features.loc[selectedList, 'x'] = \\\n                                self._layer.data[selectedList,1]\n            self._layer.features.loc[selectedList, 'y'] = \\\n                                self._layer.data[selectedList,0]\n\n    def _copy_data(self):\n        \"\"\"Copy selected points to clipboard.\n\n        Taken from napari.layers.points.points.py\n\n        This is used to capture 'state' so we can undo with _paste_data\n\n        problems with `pip install napari`\n        e.g. 'text': layer.text._copy(index)\n        gives error: AttributeError: 'TextManager' object has no attribute '_copy'\n\n        TODO (cudmore) this is changing with different version of napari.\n        \"\"\"\n        if len(self.selected_data) &gt; 0:\n            layer = self._layer  # abb\n            index = list(self.selected_data)\n            self._layerSelectionCopy = {\n                'data': deepcopy(layer.data[index]),\n                'edge_color': deepcopy(layer.edge_color[index]),\n                'face_color': deepcopy(layer.face_color[index]),\n                'shown': deepcopy(layer.shown[index]),\n                'size': deepcopy(layer.size[index]),\n                'edge_width': deepcopy(layer.edge_width[index]),\n                'features': deepcopy(layer.features.iloc[index]),\n                # 20240612\n                # AttributeError: 'Points' object has no attribute '_slice_indices'\n                # 'indices': layer._slice_indices,\n\n                #'text': layer.text._copy(index),\n            }\n            # TODO (Cudmore) layer.text.values is usually a &lt;class 'numpy.ndarray'&gt;\n            # is this always true?\n            # secondly, what is layer.text.value anyway? and what is dtype &lt;U1\n            # print(f'  === layer.text.values: \"{layer.text.values}\" {type(layer.text.values)}')\n            # print('    ', layer.text.values.shape, layer.text.values.dtype)\n            #if len(layer.text.values.shape) == 0:\n            if layer.text.values.size == 0:\n                    self._layerSelectionCopy['text'] = np.empty(0)\n            else:\n                try:\n                    self._layerSelectionCopy['text'] = deepcopy(layer.text.values[index])\n                except (IndexError) as e:\n                    logger.error('   I DO NOT UNDERSTAND HOW TO FIX THIS!')\n                    logger.error(e)\n                    self._layerSelectionCopy['text'] = np.empty(0)\n\n        else:\n            self._layerSelectionCopy = {}\n\n    def _paste_data(self, layerSelectionCopy=None):\n        \"\"\"Paste any point from clipboard and select them.\n\n        Used by undo to 'paste/add' after delete.\n\n        Copy of code in napari.layers.points.points.py\n\n        We need to swap self ... for `layer = self._layer``\n\n        Notes:\n            This is very complicated, will break on napari updates.\n            Hard to unit test.\n        \"\"\"\n        layer = self._layer\n        if layerSelectionCopy is None:\n            _clipboard = self._layerSelectionCopy\n        else:\n            _clipboard = layerSelectionCopy\n\n        npoints = len(layer._view_data)\n        totpoints = len(layer.data)\n\n        #if len(layer._clipboard.keys()) &gt; 0:\n        if len(_clipboard.keys()) &gt; 0:\n            not_disp = layer._dims_not_displayed\n            data = deepcopy(_clipboard['data'])\n            offset = [\n                layer._slice_indices[i] - _clipboard['indices'][i]\n                for i in not_disp\n            ]\n            data[:, not_disp] = data[:, not_disp] + np.array(offset)\n            layer._data = np.append(layer.data, data, axis=0)\n            layer._shown = np.append(\n                layer.shown, deepcopy(_clipboard['shown']), axis=0\n            )\n            layer._size = np.append(\n                layer.size, deepcopy(_clipboard['size']), axis=0\n            )\n\n            #layer._feature_table.append(_clipboard['features'])\n\n            #layer.text._paste(**_clipboard['text'])\n\n            layer._edge_width = np.append(\n                layer.edge_width,\n                deepcopy(_clipboard['edge_width']),\n                axis=0,\n            )\n            layer._edge._paste(\n                colors=_clipboard['edge_color'],\n                properties=_features_to_properties(\n                    _clipboard['features']\n                ),\n            )\n            layer._face._paste(\n                colors=_clipboard['face_color'],\n                properties=_features_to_properties(\n                    _clipboard['features']\n                ),\n            )\n\n            # new in `pip install napari`\n            layer._feature_table.append(_clipboard['features'])\n\n            layer._selected_view = list(\n                range(npoints, npoints + len(_clipboard['data']))\n            )\n            layer._selected_data = set(\n                range(totpoints, totpoints + len(_clipboard['data']))\n            )\n\n            if len(_clipboard['text']) &gt; 0:\n                layer.text.values = np.concatenate(\n                    (layer.text.values, _clipboard['text']), axis=0\n                )\n\n            layer.refresh()\n\n    def getDataFrame(self, getFull=False) -&gt; pd.DataFrame:\n        # getDataFrame\n        # TODO (cudmore) add symbol encoding\n\n        df = super().getDataFrame(getFull=getFull)\n\n        if getFull:\n            selectedList = list(range(len(self._layer.data)))\n        else:\n            selectedList = list(self._selected_data)\n\n        # logger.warning(f'selectedList:{selectedList}')\n\n        # now handled by _updateFeatures (only update when needed)\n        '''\n        # prepend (z,y,x)) columns\n        df.insert(0, 'x', self._layer.data[selectedList,2])\n        df.insert(0, 'y', self._layer.data[selectedList,1])\n        if self._layer.ndim == 3:\n            df.insert(0, 'z', self._layer.data[selectedList,0])\n        '''\n\n        # abb 202402 we are receiving a list of symbols\n        # prepend symbol column\n        symbol = self._layer.symbol  # str\n        # logger.warning(f'getFull:{getFull} received symbol:{symbol} {type(symbol)}')\n        # symbol = str(symbol)  # abb 20240206\n        symbol = [SYMBOL_ALIAS[str(_symbol)] for _symbol in symbol]  # abb 202402\n\n        # abb remove 202402\n        # try:\n        #     symbol = SYMBOL_ALIAS[symbol]\n        # except (KeyError) as e:\n        #     logger.warning(f'did not find symbol in SYMBOL_ALIAS named \"{symbol}\"')\n        #     symbol = 'X'\n        # # this is needed to keep number of rows correct\n        # symbolList = [symbol] * len(selectedList)  # data.shape[0]  # make symbols for each point\n\n        # abb 202402 cludge\n        #symbolList = [symbol[0]] * len(selectedList)  # data.shape[0]  # make symbols for each point\n\n        symbolList = [symbol[i] for i in selectedList]\n\n        df.insert(loc=0, column='Symbol', value=symbolList)  # insert as first column\n        # df.insert(loc=0, column='Symbol', value=symbol)  # insert as first column\n\n        return df\n\n    def addAnnotation(self, coords, event=None, features:dict = None):\n        \"\"\"Add a single annotation to a layer.\n\n        Define when deriving. For points layer use 'self._layer.add(cords)'\n\n        Notes:\n            Does not seem to be a simple way to add points to existing layer.\n            This does not set properties/features correctly\n        \"\"\"\n\n        '''\n        if event is not None:\n            print('calling _points_mouse_bindings()')\n            _points_mouse_bindings.add(self._layer, event)\n        else:\n            self._layer.add(coords)\n        '''\n\n        #\n        # IMPORTANT !!!!\n        #\n        # do the add (napari), this TRIGGERS\n        # add events before it returns\n        self._layer.add(coords)  # napari function call\n\n        # point was added and all callbacks responded\n\n        # assign features\n        logger.info('assigning features from external return dict')\n        addedIdx = self._numItems  # after added\n        addedIdx -= 1\n        for featureColumn in self._layer.features.columns:\n            if featureColumn in features.keys():\n                addedFeatureValue = features[featureColumn]\n                print(f'      addedIdx:{addedIdx} featureColumn:{featureColumn} addedFeatureValue:{addedFeatureValue}')\n                self._layer.features.loc[addedIdx, featureColumn] = addedFeatureValue\n            else:\n                # _layer has a feature we did not set???\n                print(f'  did not find featureColumn:{featureColumn} in added features')\n                pass\n\n    def _flashItem(self, selectedRow : int):\n        \"\"\"Flash size/color if selected item to make it visible to user.\n\n        Notes:\n            layer.refresh() did not do update, instead we are\n            tapping into and refreshing Qt in the event loop with \n                get_app().processEvents()\n        \"\"\"\n\n        # parameter\n        # _numFlash = 3\n        # _sleep1 = 0.07\n        # _sleep2 = 0.04\n\n        # logger.info(f'_numFlash:{_numFlash} _sleep1:{_sleep1} _sleep2:{_sleep2}')\n\n        _origColor = self._layer.face_color[selectedRow].copy()\n        _origSize = self._layer.size[selectedRow].copy()\n        # _flashColor = [1., 1., 0., 1.]\n        # _flashSize = _origSize / 2\n\n        # we really need to create a timer object because\n        # multiple calls will collide when they overwrite self._flashTimerIteration\n        if self._flashTimer is not None and self._flashTimer.isActive():\n            logger.warning(f'flash timer was still running')\n            return\n\n        self._flashTimerInterval = 30  # ms\n        self._flashTimerIterations = 6  # must be even\n        self._flashTimerIteration = 0\n\n        logger.info(f'{self._flashTimerIterations} iterations at interval {self._flashTimerInterval} ms')\n\n        self._flashTimer = QtCore.QTimer(self)\n        self._flashTimer.setInterval(30)  # ms\n\n        _origColor = self._layer.face_color[selectedRow].copy()\n        _origSize = self._layer.size[selectedRow].copy()\n\n        _callback = lambda selectedRow=selectedRow, _origColor=_origColor, _origSize=_origSize \\\n            : self._on_flash_timer(selectedRow, _origColor, _origSize)\n        self._flashTimer.timeout.connect(_callback)\n        self._flashTimer.start()\n\n    def _on_flash_timer(self, selectedRow, _origColor, _origSize):\n        \"\"\"Called when self.xxx QTimer times out\n        \"\"\"\n        doFlash = self._flashTimerIteration % 2 == 0\n\n        # logger.info(f'    _flashTimerIteration:{self._flashTimerIteration} doFlash:{doFlash}')\n\n        _flashColor = [1., 1., 0., 1.]\n        #_flashSize = _origSize / 2\n        _flashSize = _origSize * 3\n\n        # do flash\n        if doFlash:\n            self._layer.face_color[selectedRow] = _flashColor\n            self._layer.size[selectedRow] = _flashSize\n            self._layer.refresh()\n            get_app().processEvents()\n            #time.sleep(_sleep1)\n        else:\n            self._layer.face_color[selectedRow] = _origColor\n            self._layer.size[selectedRow] = _origSize\n            self._layer.refresh()\n            get_app().processEvents()\n            #time.sleep(_sleep2)\n\n        # increment\n        self._flashTimerIteration += 1\n        if self._flashTimerIteration &gt;= self._flashTimerIterations:\n            self._flashTimer.stop()\n\n    def snapToItem(self, selectedRow : int, isAlt : bool =False):\n        \"\"\"Snap viewer to z-Plane of selected row and optionally to (y,x)\n\n        Only snap when one row is selected, not multiple.\n\n        Args:\n            selectedRow (int): The row to snap to.\n            isAlt (bool): If True then center point on (y,x)\n\n        TODO:\n            \"Setting the camera center also resets the zoom\"\n            see: https://github.com/napari/napari/issues/3723\n            on 20220322, was closed and should be fixed with next version of vispy\n            see: https://github.com/vispy/vispy/pull/2312\n        \"\"\"\n        isThreeD = self._layer.data.shape[1] == 3\n\n        if isThreeD:\n            zSlice = self._layer.data[selectedRow][0]  # assuming (z,y,x)\n            yPnt = self._layer.data[selectedRow][1]  # assuming (z,y,x)\n            xPnt = self._layer.data[selectedRow][2]  # assuming (z,y,x)\n            logger.info(f'selectedRow:{selectedRow} zSlice:{zSlice} y:{yPnt} x:{xPnt}')\n\n            # z-Plane\n            axis = 0 # assuming (z,y,x)\n            self._viewer.dims.set_point(axis, zSlice)\n\n            # (y,x)\n            if isAlt:\n                self._viewer.camera.center = (zSlice, yPnt, xPnt)\n\n        else:\n            yPnt = self._layer.data[selectedRow][0]  # assuming (z,y,x)\n            xPnt = self._layer.data[selectedRow][1]  # assuming (z,y,x)\n            logger.info(f'y:{yPnt} x:{xPnt}')\n            if isAlt:\n                self._viewer.camera.center = (yPnt, xPnt)\n\n        # flash selection to make it visible to user\n        self._flashItem(selectedRow)\n\n    def slot_user_edit_symbol(self, event):\n        \"\"\"Respond to user selecting a new symbol.\n\n        Special case, all points in layer have same symbol, \n        need to refresh entire table.\n        \"\"\"\n\n        # TODO (cudmore) add mmLayer.emitChangeAll()\n\n        all_selected_data = set(range(self.numItems()))\n\n        logger.info(f'--&gt;&gt; emit change with all_selected_data:{all_selected_data}')\n\n        #selected_data2 = self._layer.data\n        dfFeatures = self.getDataFrame(getFull=True)\n\n        # TODO (cudmore) we do not want changeSymbol to be part of undo\n        self.signalDataChanged.emit('change', all_selected_data,\n                            #self._layerSelectionCopy,\n                            dict(),\n                            dfFeatures)\n\n    def slot_user_edit_size(self, event):\n        logger.info('  --&gt;&gt; NOT IMPLEMENTED')\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.pointsLayer.addAnnotation","title":"<code>addAnnotation(coords, event=None, features=None)</code>","text":"<p>Add a single annotation to a layer.</p> <p>Define when deriving. For points layer use 'self._layer.add(cords)'</p> Notes <p>Does not seem to be a simple way to add points to existing layer. This does not set properties/features correctly</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def addAnnotation(self, coords, event=None, features:dict = None):\n    \"\"\"Add a single annotation to a layer.\n\n    Define when deriving. For points layer use 'self._layer.add(cords)'\n\n    Notes:\n        Does not seem to be a simple way to add points to existing layer.\n        This does not set properties/features correctly\n    \"\"\"\n\n    '''\n    if event is not None:\n        print('calling _points_mouse_bindings()')\n        _points_mouse_bindings.add(self._layer, event)\n    else:\n        self._layer.add(coords)\n    '''\n\n    #\n    # IMPORTANT !!!!\n    #\n    # do the add (napari), this TRIGGERS\n    # add events before it returns\n    self._layer.add(coords)  # napari function call\n\n    # point was added and all callbacks responded\n\n    # assign features\n    logger.info('assigning features from external return dict')\n    addedIdx = self._numItems  # after added\n    addedIdx -= 1\n    for featureColumn in self._layer.features.columns:\n        if featureColumn in features.keys():\n            addedFeatureValue = features[featureColumn]\n            print(f'      addedIdx:{addedIdx} featureColumn:{featureColumn} addedFeatureValue:{addedFeatureValue}')\n            self._layer.features.loc[addedIdx, featureColumn] = addedFeatureValue\n        else:\n            # _layer has a feature we did not set???\n            print(f'  did not find featureColumn:{featureColumn} in added features')\n            pass\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.pointsLayer.slot_user_edit_symbol","title":"<code>slot_user_edit_symbol(event)</code>","text":"<p>Respond to user selecting a new symbol.</p> <p>Special case, all points in layer have same symbol,  need to refresh entire table.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def slot_user_edit_symbol(self, event):\n    \"\"\"Respond to user selecting a new symbol.\n\n    Special case, all points in layer have same symbol, \n    need to refresh entire table.\n    \"\"\"\n\n    # TODO (cudmore) add mmLayer.emitChangeAll()\n\n    all_selected_data = set(range(self.numItems()))\n\n    logger.info(f'--&gt;&gt; emit change with all_selected_data:{all_selected_data}')\n\n    #selected_data2 = self._layer.data\n    dfFeatures = self.getDataFrame(getFull=True)\n\n    # TODO (cudmore) we do not want changeSymbol to be part of undo\n    self.signalDataChanged.emit('change', all_selected_data,\n                        #self._layerSelectionCopy,\n                        dict(),\n                        dfFeatures)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.pointsLayer.snapToItem","title":"<code>snapToItem(selectedRow, isAlt=False)</code>","text":"<p>Snap viewer to z-Plane of selected row and optionally to (y,x)</p> <p>Only snap when one row is selected, not multiple.</p> <p>Parameters:</p> Name Type Description Default <code>selectedRow</code> <code>int</code> <p>The row to snap to.</p> required <code>isAlt</code> <code>bool</code> <p>If True then center point on (y,x)</p> <code>False</code> TODO <p>\"Setting the camera center also resets the zoom\" see: https://github.com/napari/napari/issues/3723 on 20220322, was closed and should be fixed with next version of vispy see: https://github.com/vispy/vispy/pull/2312</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def snapToItem(self, selectedRow : int, isAlt : bool =False):\n    \"\"\"Snap viewer to z-Plane of selected row and optionally to (y,x)\n\n    Only snap when one row is selected, not multiple.\n\n    Args:\n        selectedRow (int): The row to snap to.\n        isAlt (bool): If True then center point on (y,x)\n\n    TODO:\n        \"Setting the camera center also resets the zoom\"\n        see: https://github.com/napari/napari/issues/3723\n        on 20220322, was closed and should be fixed with next version of vispy\n        see: https://github.com/vispy/vispy/pull/2312\n    \"\"\"\n    isThreeD = self._layer.data.shape[1] == 3\n\n    if isThreeD:\n        zSlice = self._layer.data[selectedRow][0]  # assuming (z,y,x)\n        yPnt = self._layer.data[selectedRow][1]  # assuming (z,y,x)\n        xPnt = self._layer.data[selectedRow][2]  # assuming (z,y,x)\n        logger.info(f'selectedRow:{selectedRow} zSlice:{zSlice} y:{yPnt} x:{xPnt}')\n\n        # z-Plane\n        axis = 0 # assuming (z,y,x)\n        self._viewer.dims.set_point(axis, zSlice)\n\n        # (y,x)\n        if isAlt:\n            self._viewer.camera.center = (zSlice, yPnt, xPnt)\n\n    else:\n        yPnt = self._layer.data[selectedRow][0]  # assuming (z,y,x)\n        xPnt = self._layer.data[selectedRow][1]  # assuming (z,y,x)\n        logger.info(f'y:{yPnt} x:{xPnt}')\n        if isAlt:\n            self._viewer.camera.center = (yPnt, xPnt)\n\n    # flash selection to make it visible to user\n    self._flashItem(selectedRow)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.shapesLayer","title":"<code>shapesLayer</code>","text":"<p>               Bases: <code>mmLayer</code></p> <p>event.source.mode in:     'direct': allows for shapes to be selected and their individual vertices to be moved.     'select': allows for entire shapes to be selected, moved and resized.     'VERTEX_INSERT':      'VERTEX_REMOVE':</p> shape_type in <p>'path': A list (array) of points making a path</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>class shapesLayer(mmLayer):\n    \"\"\"\n    event.source.mode in:\n        'direct': allows for shapes to be selected and their individual vertices to be moved.\n        'select': allows for entire shapes to be selected, moved and resized.\n        'VERTEX_INSERT': \n        'VERTEX_REMOVE':\n\n    shape_type in:\n        'path': A list (array) of points making a path\n    \"\"\"\n    def __init__(self, viewer, layer, *args, **kwargs):\n        super().__init__(viewer, layer, *args, **kwargs)\n\n        self.addFeature('x')\n        self.addFeature('y')\n        self.addFeature('z')\n\n        self._updateFeatures()\n\n    def getDataFrame(self, getFull=False) -&gt; pd.DataFrame:\n        # TODO (cudmore) make sure it works for 2d/3d (what about N-Dim ???)\n\n        df = super().getDataFrame(getFull=getFull)\n\n        if getFull:\n            selectedList = list(range(len(self._layer.data)))\n        else:\n            selectedList = list(self._selected_data)\n\n        # now handled in _updateFeatures\n        # iterate through each shape and calculate (z,y,x)      \n        '''\n        yMean = [np.mean(self._layer.data[idx][:,1]) for idx in selectedList]\n        xMean = [np.mean(self._layer.data[idx][:,2]) for idx in selectedList]\n\n        df.insert(0, 'x', xMean)\n        df.insert(0, 'y', yMean)\n        if self._layer.ndim == 3:\n            zMean = [np.mean(self._layer.data[idx][:,0]) for idx in selectedList]\n            df.insert(0, 'z', zMean)\n        '''\n\n        shape_type = [self._layer.shape_type[idx] for idx in selectedList]        \n        df.insert(0, 'Shape Type', shape_type)\n\n        return df\n\n    def _updateFeatures(self, selectedDataSet=None):\n        \"\"\"Update underlying layer features based on selection.\n\n        Used in creation and on data move.\n\n        Args:\n            selectedDataSet (set) selected data, Pass None to update all.\n        \"\"\"\n        if selectedDataSet is None:\n            selectedDataSet = set(range(self.numItems()))\n\n        selectedList = list(selectedDataSet)\n\n        logger.info(f'{self._derivedClassName()} selectedList:{selectedList}')\n        logger.info(f'self._layer.data is:')\n        print(self._layer.data)\n\n        if self._layer.ndim == 2:\n            yMean = [np.mean(self._layer.data[idx][:,0]) for idx in selectedList]\n            xMean = [np.mean(self._layer.data[idx][:,1]) for idx in selectedList]\n\n            self._layer.features.loc[selectedList, 'x'] = xMean\n            self._layer.features.loc[selectedList, 'y'] = yMean\n\n        elif self._layer.ndim &gt;= 3:\n            yMean = [np.mean(self._layer.data[idx][:,1]) for idx in selectedList]\n            xMean = [np.mean(self._layer.data[idx][:,2]) for idx in selectedList]\n\n            self._layer.features.loc[selectedList, 'x'] = xMean\n            self._layer.features.loc[selectedList, 'y'] = yMean\n\n            zMean = [np.mean(self._layer.data[idx][:,0]) for idx in selectedList]\n            self._layer.features.loc[selectedList, 'z'] = zMean\n\n        else:\n            logger.warning(f'Did not update with self._layer.ndim:{self._layer.ndim}')\n\n        print('   now self._layer.features:')\n        pprint(self._layer.features)\n\n    def _copy_data(self):\n        \"\"\"Copy selected shapes to clipboard.\n\n        Taken from napari.layers.shapes.shapes.py\n\n        This is buggy, depends on napari version !!!\n        \"\"\"\n        if len(self.selected_data) &gt; 0:\n            layer = self._layer\n            index = list(self.selected_data)\n            self._layerSelectionCopy = {\n                'data': [\n                    deepcopy(layer._data_view.shapes[i])\n                    for i in layer._selected_data\n                ],\n                'edge_color': deepcopy(layer._data_view._edge_color[index]),\n                'face_color': deepcopy(layer._data_view._face_color[index]),\n                'features': deepcopy(layer.features.iloc[index]),\n                'indices': layer._slice_indices,\n                'text': layer.text._copy(index),  # abb 202402 un-commented\n            }\n\n            # abb remove 202402\n            # if len(layer.text.values) == 0:\n            #     self._layerSelectionCopy['text'] = np.empty(0)\n            # else:\n            #     try:\n            #         self._layerSelectionCopy['text'] = deepcopy(layer.text.values[index])\n            #     except (IndexError) as e:\n            #         logger.error(f'I DO NOT UNDERSTAND HOW TO FIX THIS! {e}')\n            #         self._layerSelectionCopy['text'] = np.empty(0)\n        else:\n            self._layerSelectionCopy = {}\n\n    def _paste_data(self, layerSelectionCopy=None):\n        \"\"\"Paste any shapes from clipboard and then selects them.\n\n        Copy of code in napari.layers.shapes.shapes.py\n\n        We need to swap self ... for `layer = self._layer``\n\n        Notes:\n            This is very complicated, will break on napari updates.\n            Hard to unit test.\n        \"\"\"\n        layer = self._layer  # replaces self.\n        if layerSelectionCopy is None:\n            _clipboard = self._layerSelectionCopy\n        else:\n            _clipboard = layerSelectionCopy\n\n        cur_shapes = layer.nshapes\n        if len(_clipboard.keys()) &gt; 0:\n            # Calculate offset based on dimension shifts\n            offset = [\n                layer._slice_indices[i] - _clipboard['indices'][i]\n                for i in layer._dims_not_displayed\n            ]\n\n            layer._feature_table.append(_clipboard['features'])\n\n            # Add new shape data\n            for i, s in enumerate(_clipboard['data']):\n                shape = deepcopy(s)\n                data = copy(shape.data)\n                data[:, layer._dims_not_displayed] = data[\n                    :, layer._dims_not_displayed\n                ] + np.array(offset)\n                shape.data = data\n                face_color = _clipboard['face_color'][i]\n                edge_color = _clipboard['edge_color'][i]\n                layer._data_view.add(\n                    shape, face_color=face_color, edge_color=edge_color\n                )\n\n            if len(_clipboard['text']) &gt; 0:\n                layer.text.values = np.concatenate(\n                    (layer.text.values, _clipboard['text']), axis=0\n                )\n\n            layer.selected_data = set(\n                range(cur_shapes, cur_shapes + len(_clipboard['data']))\n            )\n\n            layer.move_to_front()\n\n    def slot_user_edit_data(self, event):        \n        super().slot_user_edit_data(event)\n        #logger.info('shapesLayer')\n        #self._printEventState(event)\n\n    def _printEventState(self, event):\n        print('    === _printEventState()')\n        print('      event.source.mode:', event.source.mode)\n        print('      event.source.selected_data:', event.source.selected_data)\n        print('      len(event.source.data):', len(event.source.data))\n        print('      self.numItems():', self.numItems())\n        print('      self._selected_data:', self._selected_data)\n        #print('      self._selected_data2:', self._selected_data2)\n\n    def addShapes(self, data, shape_type):\n        #if not isinstance(shape_type, list):\n        #    shape_type = [shape_type]\n\n        #print('shapeLayer.addShapes()')\n        #print('  data:', type(data))\n        #print('  shape_type:', shape_type)\n        if shape_type == 'polygon':\n            self._layer.add_polygons(data)\n        elif shape_type == 'path':\n            self._layer.add_paths(data)\n</code></pre>"},{"location":"api/_my_layer/#napari_layer_table._my_layer.setsAreEqual","title":"<code>setsAreEqual(a, b)</code>","text":"<p>Convenience function. Return true if sets (a, b) are equal.</p> Source code in <code>src/napari_layer_table/_my_layer.py</code> <pre><code>def setsAreEqual(a, b):\n    \"\"\"Convenience function. Return true if sets (a, b) are equal.\n    \"\"\"\n    if len(a) != len(b):\n        return False\n    for x in a:\n        if x not in b:\n            return False\n    return True\n</code></pre>"},{"location":"api/_my_widget/","title":"_my_widget","text":"<p>Widget to display points layer as a table.</p> <ul> <li>The selected layer is displayed in the table.</li> <li> <p>The table has columns for:</p> <ul> <li>Point symbol with face color</li> <li>Point coordinates (x,y,z)</li> <li>If the layer has properties, these are also columns</li> </ul> </li> <li> <p>Bi-directional selection between layer and table.</p> </li> <li>Bi-directional delete between layer and table.</li> <li>Points added to the layer are added to the table.</li> <li>Points moved in the layer are updated in the table.</li> <li>Changes to face color and symbol in the layer are updated in the table.</li> </ul> <p>Right-click for context menu to:</p> <ul> <li>Toggle table columns on/off.</li> <li>Toggle shift+click to add a point to the layer (no need to switch viewer mode)</li> <li>Copy table to clipboard</li> </ul>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin","title":"<code>LayerTablePlugin</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>class LayerTablePlugin(QtWidgets.QWidget):\n    acceptedLayers = (napari.layers.Points,\n                        napari.layers.Shapes,\n                        napari.layers.Labels)\n\n    # TODO (cudmore) add this back in when we allow user edit of cell(s)\n    ltp_signalDataChanged = QtCore.Signal(str, set, pd.DataFrame)\n    \"\"\"Emit signal to the external code when user adds and deletes items.\n       Emits:\n           (str) event type which can be \"add\", \"move\" or \"delete\" \n            (pd.DataFrame) for the edited row\n    \"\"\"\n\n    ltp_signalEditedRows = QtCore.Signal(object, object)\n    \"\"\"Signal emited after user edited table data and we accepted it.\n\n    Args:\n        rows (List[int])\n        df (df.DataFrame)\n    \"\"\"\n\n    def __init__(self, napari_viewer : napari.Viewer,\n                    oneLayer=None,\n                    onAddCallback=None):\n        \"\"\"A widget to display a layer as a table.\n\n        Allows bi-directional selection and editing.\n\n        Args:\n            viewer (napari.Viewer): Existing napari viewer.\n            oneLayer (layer): If given then connect to this one layer,\n                            otherwise, connect to all existing layers.\n            onAddCallback (func) function is called on shift+click\n                params(set, pd.DataFrame)\n                return Union[None, dict]\n\n        Raises:\n            ValueError: If napari_viewer does not have a valid selected layer.\n                Designed to work with (points, shapes, labels) layers.\n                and to work with one Napari layer.\n\n        TODO (cudmore) check params and return of onAddCallback\n            takes a string and returns ???\n\n        TODO (cudmore) once we are created with an accpeted layer.\n            Need to close the plugin (?) if user deletes the layer?\n        \"\"\"\n        super().__init__()\n\n        warnings.filterwarnings(\n            action='ignore',\n            category=FutureWarning\n        )\n\n        self._viewer = napari_viewer\n\n        if oneLayer is None:\n            oneLayer = self._findActiveLayers()\n\n        # if oneLayer is None:\n        #     logger.error(f'did not find a layer ???')\n\n        # _myLayer is from our class hierarchy to fix interface problems\n        #   with variable layers in napari\n\n        if isinstance(oneLayer, napari.layers.points.points.Points):\n            self._myLayer = _my_layer.pointsLayer(self._viewer, oneLayer, onAddCallback=onAddCallback)\n        elif isinstance(oneLayer, napari.layers.shapes.shapes.Shapes):\n            self._myLayer = _my_layer.shapesLayer(self._viewer, oneLayer, onAddCallback=onAddCallback)\n        elif isinstance(oneLayer, napari.layers.labels.labels.Labels):\n            self._myLayer = _my_layer.labelLayer(self._viewer, oneLayer, onAddCallback=onAddCallback)\n        else:\n            self._myLayer = None  # ERROR\n            logger.error(f'Did not understand layer of type: {type(oneLayer)}')\n            logger.error(f'Expecting a viewer with an active layer in {self.acceptedLayers}')\n            raise ValueError\n\n        #self._layer = oneLayer\n        # actual napari layer\n\n        # we have layer in our list of 'acceptedLayers'\n        self._myLayer.signalDataChanged.connect(self.slot2_layer_data_change)\n        self._myLayer.signalLayerNameChange.connect(self.slot2_layer_name_change)\n\n        # used to halt callbacks to prevent signal/slot recursion\n        self._blockUserTableSelection = False\n        self._blockDeleteFromTable = False\n\n        self._showProperties = True  # Toggle point properties columns\n        self._showCoordinates = True  # Toggle point coordinates columns (z,y,x)\n        self._shift_click_for_new = False  # Toggle new points on shift+click\n        #self._showFaceColor = True\n\n        # If True, will not switch to different layer\n        #self._onlyOneLayer = oneLayer is not None\n\n        #self.myTable = None\n        self._initGui()  # order matters, connectLayer() is accessing table\n                        # but table has to first be created\n\n        self.slot2_layer_name_change(self._myLayer.getName())\n\n        # key binding are confusing\n        # i want keyboard 'a' to toggle selected row, 'accept' column\n        #self.setFocusPolicy(QtCore.Qt.StrongFocus)\n        #self._viewer.bind_key('i', self._key_i_pressed)\n\n        self.refresh()  # refresh entire table\n\n    # no work\n    # def keyPressEvent(self, event):\n    #     logger.info('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')\n\n    #@self.viewer.bind_key('i')\n    # def _key_i_pressed(self, viewer):\n    #     logger.info('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')\n\n    def getTableView(self):\n        \"\"\"Get underlying QTableView.\n        \"\"\"\n        return self.myTable2\n\n    def newOnShiftClick(self, on : bool):\n        \"\"\"Toggle shift+click for new.\n        \"\"\"\n        self._myLayer.newOnShiftClick(on)\n\n    def slot2_layer_data_change(self, action :str,\n                        selection : set,\n                        layerSelectionCopy : dict,\n                        df : pd.DataFrame):\n        \"\"\"Respond to user interface change through liazon myLayer.\n\n            TODO (cudmore) data is not used???\n        \"\"\"\n        '''\n        logger.info('')\n        print('    action:', action)\n        print('    selection:', selection)\n        print('    data:', data)\n        print('    df:')\n        pprint(df)\n        '''\n\n        if action == 'select':\n            # TODO (cudmore) if Layer is labaeled then selection is a list\n            if isinstance(selection, list):\n                selection = set(selection)\n            self.selectInTable(selection)\n            self.ltp_signalDataChanged.emit(action, selection, df)\n\n        elif action == 'add':\n            #addedRowList = selection\n            #myTableData = self.getLayerDataFrame(rowList=addedRowList)\n            myTableData = df\n            self.myTable2.myModel.myAppendRow(myTableData)\n            self.selectInTable(selection)\n            self.ltp_signalDataChanged.emit(action, selection, df)\n\n        elif action == 'delete':\n            # was this\n            deleteRowSet = selection\n            #logger.info(f'myEventType:{myEventType} deleteRowSet:{deleteRowSet}')\n            #deletedDataFrame = self.myTable2.myModel.myGetData().iloc[list(deleteRowSet)]\n\n            self._deleteRows(deleteRowSet)\n\n            #self._blockDeleteFromTable = True\n            #self.myTable2.myModel.myDeleteRows(deleteRowList)\n            #self._blockDeleteFromTable = False\n\n            self.ltp_signalDataChanged.emit(action, selection, df)\n\n        elif action == 'change':\n            moveRowList = list(selection) #rowList is actually indexes\n            myTableData = df\n            #myTableData = self.getLayerDataFrame(rowList=moveRowList)\n\n            # this is what I call on a keystroke like 'a' for accept but interface is not updated???\n            self.myTable2.myModel.mySetRow(moveRowList, myTableData, ignoreAccept=True)\n\n            logger.warning('!!! we emit ltp_signalDataChanged but it is not connected to anybody')\n            self.ltp_signalDataChanged.emit(action, selection, df)\n        else:\n            logger.info(f'did not understand action: \"{action}\"')\n\n    def slot2_layer_name_change(self, name :str):\n        #logger.info(f'name is now: {name}')\n        self.layerNameLabel.setText(name)\n\n    def _initGui(self):\n\n        # main vertical layout\n        vbox_layout = QtWidgets.QVBoxLayout()\n\n        # one row of controls\n        controls_hbox_layout = QtWidgets.QHBoxLayout()\n\n        # full refresh of table\n        # refreshButton = QtWidgets.QPushButton('Refresh')\n        # refreshButton.setToolTip('Refresh the entire table')\n        # refreshButton.clicked.connect(self.on_refresh_button)\n        # controls_hbox_layout.addWidget(refreshButton)\n\n        # bring layer to front in napari viewer\n        #if self._onlyOneLayer:\n        bringToFrontButton = QtWidgets.QPushButton('')\n        bringToFrontButton.setToolTip('Bring layer to front')\n        # want to set an icon, temporary use built in is SP_TitleBarNormalButton\n        #TODO (cudmore) install our own .svg icons, need to use .qss file\n        style = self.style()\n        bringToFrontButton.setIcon(\n                    style.standardIcon(QtWidgets.QStyle.SP_FileIcon))\n\n        bringToFrontButton.clicked.connect(self.on_bring_to_front_button)\n        controls_hbox_layout.addWidget(bringToFrontButton, alignment=QtCore.Qt.AlignLeft)\n\n        # TODO: not implemented\n        # undoButton = QtWidgets.QPushButton('Undo')\n        # undoButton.setToolTip('Undo')\n        # # want to set an icon, temporary use built in is SP_TitleBarNormalButton\n        # #TODO (cudmore) install our own .svg icons, need to use .qss file\n        # style = self.style()\n        # #undoButton.setIcon(\n        # #            style.standardIcon(QtWidgets.QStyle.SP_BrowserReload))\n\n        # undoButton.clicked.connect(self.on_undo_button)\n        # controls_hbox_layout.addWidget(undoButton)\n\n        # the current layer name\n        self.layerNameLabel = QtWidgets.QLabel('')\n        controls_hbox_layout.addWidget(self.layerNameLabel, alignment=QtCore.Qt.AlignLeft)\n\n        controls_hbox_layout.addStretch()\n\n        vbox_layout.addLayout(controls_hbox_layout)\n\n        self.myTable2 = myTableView()\n        #self.myTable2.setFontSize(11)\n        # to pass selections in table back to the viewer\n        self.myTable2.signalSelectionChanged.connect(self.slot_selection_changed)\n        self.myTable2.mtv_signalEditingRows.connect(self.slot_editingRows)\n        # Important: we need to disconnect this signal if we have\n        # a dedicated backend with data and table is a copy\n        self.ltp_signalEditedRows.connect(self.myTable2.slot_editedRows)\n\n        vbox_layout.addWidget(self.myTable2)\n\n        # finalize\n        self.setLayout(vbox_layout)\n\n    def _findActiveLayers(self):\n        \"\"\"Find pre-existing selected layer.\n        \"\"\"\n        for layer in self._viewer.layers:\n            if isinstance(layer, self.acceptedLayers):\n                if layer == self._viewer.layers.selection.active:\n                    # connect to existing active layer\n                    return layer\n        return None\n\n    def old_on_refresh_button(self):\n        \"\"\"TODO: need to preserve 'accept' column.\n        \"\"\"\n        logger.info('')\n        self.refresh()\n\n    def on_bring_to_front_button(self):\n        \"\"\"Bring the layer to the front in napari viewer.\n\n        TODO (cudmore): update to _my_layer\n        \"\"\"\n        logger.info('')\n        self._myLayer.bringToFront()\n        #if self._viewer.layers.selection.active != self._myLayer:\n        #    #print('  seting layer in viewer')\n        #    self._viewer.layers.selection.active = self._myLayer\n\n    def old_on_undo_button(self):\n        self._myLayer.doUndo()\n\n    def connectLayer(self, layer):\n        \"\"\"Connect to one layer.\n\n        Args:\n            layer (layer): Layer to connect to.\n\n        TODO:\n            Need to handle layer=None and just empty the interface\n        \"\"\"\n        logger.error('TODO (cudmore) need to refactor this !!!')\n        logger.error('  basically all calls to connect have to go through our layer heirarchy in _my_layer ...')\n        return\n\n        #if layer is None:\n        #    return\n\n        if layer is not None and not isinstance(layer, self.acceptedLayers):\n            logger.warning(f'layer with type {type(layer)} was not in {self.acceptedLayers}')\n            return\n\n        logger.info(f'Connecting to layer \"{layer}\"')\n\n        # disconnect from existing (previous) layer\n        if self._layer is not None:\n            self._layer.events.data.disconnect(self.slot_user_edit_data)\n            self._layer.events.name.disconnect(self.slot_user_edit_name)\n            self._layer.events.symbol.disconnect(self.slot_user_edit_symbol)\n            self._layer.events.size.disconnect(self.slot_user_edit_size)\n            self._layer.events.highlight.disconnect(self.slot_user_edit_highlight)\n\n            # special case\n            self._layer.events.face_color.disconnect(self.slot_user_edit_face_color)\n            self._layer._face.events.current_color.disconnect(self.slot_user_edit_face_color)\n\n        self._layer = layer\n\n        # if layer is None, hide interface\n        if self._layer is None:\n            logger.info('no layer selection ,hiding interface')\n            # TODO (cudmore) the following is not needed, just hide the widget\n            #emptyDataFrame = pd.DataFrame()\n            # set name to ''\n            #self.layerNameLabel.setText('')\n            # set table to empty\n            #self._refreshTableData(emptyDataFrame)\n            self.hide()\n            return\n        else:\n            self.show()\n\n        # display the name of the layer\n        self.layerNameLabel.setText(self._layer.name)\n\n        # AttributeError: 'pointsLayer' object has no attribute 'events'\n        self._layer.events.data.connect(self.slot_user_edit_data)\n        self._layer.events.name.connect(self.slot_user_edit_name)\n        self._layer.events.symbol.connect(self.slot_user_edit_symbol)\n        self._layer.events.size.connect(self.slot_user_edit_size)\n        self._layer.events.highlight.connect(self.slot_user_edit_highlight)\n\n        # this does not call our callback ... bug in napari???\n        self._layer.events.face_color.connect(self.slot_user_edit_face_color)\n        # this works but layer is not updated yet\n        try:\n            self._layer._face.events.current_color.connect(self.slot_user_edit_face_color)\n        except (AttributeError) as e:\n            logger.warning(e)\n\n        # important: when user switches layers, napari does not visually switch selections?\n        # but the layer does remember it. Set it to empty set()\n        # otherwise our interface would re-select the previous selection\n        self._layer.selected_data = set()\n        self._selectedData = None\n\n        self._updateMouseCallbacks()\n\n        # TODO: remove this, should by part of map manager\n        # leaving it here as proof-of-concept\n        #self._myLayer.mouse_wheel_callbacks.append(self.on_mouse_wheel)\n\n        # full refresh of table\n        self.refresh()\n\n    def refresh(self):\n        \"\"\"Refresh entire table with current layer.\n\n        Note:\n            This refreshes entire table (slow).\n            Should only be used on table creation and layer switching.\n            Do not use for edits like add, delete, change/move.\n        \"\"\"\n        #layerDataFrame = self.getLayerDataFrame()\n        layerDataFrame = self._myLayer.getDataFrame(getFull=True)\n        self._refreshTableData(layerDataFrame)\n\n    def _refreshTableData(self, df : pd.DataFrame):\n        \"\"\"Refresh all data in table by setting its data model from provided dataframe.\n\n        Args:\n            df (pd.DataFrame): Pandas dataframe to refresh with.\n        \"\"\"\n\n        if self.myTable2 is None:\n            # interface has not been initialized\n            return\n\n        if df is None:\n            return\n\n        logger.info(f'Full refresh ... limit use of this')\n        logger.info(f'refreshing from df:')\n        print(df)\n\n        myModel = pandasModel(df)\n        self.myTable2.mySetModel(myModel)\n\n    def contextMenuEvent(self, event):\n        \"\"\"Show a context menu on mouse right-click.\n\n        This is an inherited function of QWidget.\n        \"\"\"\n\n        # create the menu\n        contextMenu = QtWidgets.QMenu(self)\n\n        # add menu item actions\n        showCoordinates = contextMenu.addAction(\"Coordinates\")\n        showCoordinates.setCheckable(True)\n        showCoordinates.setChecked(self._showCoordinates)\n\n        showProperties = contextMenu.addAction(\"Properties\")\n        showProperties.setCheckable(True)\n        showProperties.setChecked(self._showProperties)\n\n        #showFaceColor = contextMenu.addAction(\"Face Color\")\n        #showFaceColor.setCheckable(True)\n        #showFaceColor.setChecked(self._showFaceColor)\n\n        contextMenu.addSeparator()\n        shiftClickForNew = contextMenu.addAction(\"Shift+Click for new\")\n        shiftClickForNew.setCheckable(True)\n        shiftClickForNew.setChecked(self._shift_click_for_new)\n\n        #contextMenu.addSeparator()\n        copyTable = contextMenu.addAction(\"Copy Table To Clipboard\")\n\n        contextMenu.addSeparator()\n\n        # all columns in pandas data model\n        columns = self.myTable2.getColumns()\n        for column in columns:\n            isHidden = column in self.myTable2.hiddenColumnSet\n            columnAction = contextMenu.addAction(column)\n            columnAction.setCheckable(True)\n            columnAction.setChecked(not isHidden)\n\n        # all properties in pandas data\n        # these are part of columns\n\n        # show the popup menu\n        action = contextMenu.exec_(self.mapToGlobal(event.pos()))\n\n        # take action\n        if action == showCoordinates:\n            self._showCoordinates = action.isChecked()\n            self.hideColumns('coordinates', not action.isChecked())\n        elif action == showProperties:\n            self._showProperties = action.isChecked()\n            self.hideColumns('properties', not action.isChecked())\n\n        elif action == shiftClickForNew:\n            self._shift_click_for_new = not self._shift_click_for_new    \n            #self._updateMouseCallbacks()\n            self._myLayer._updateMouseCallbacks(self._shift_click_for_new)\n\n        elif action == copyTable:\n            self.myTable2.myModel.myCopyTable()\n\n        elif action is not None:\n            # show/hide individual comuns\n            column = action.text()\n            hidden = column in self.myTable2.hiddenColumnSet\n            self.myTable2.mySetColumnHidden(column, not hidden)  # toggle hidden\n\n        #elif action is not None:\n        #    logger.warning(f'action not taken \"{action.text()}\"')\n\n    def hideColumns(self, columnType : str, hidden : bool = True):\n        \"\"\"Hide different sets of columns.\n\n        Args:\n            columnType (str): from\n                - 'coordinates': Show or hide (z, y, x) columns.\n                - 'properties': Show or hide all layer property key columns.\n            hidden (bool): If true then column will be hidden, otherwise show.\n        \"\"\"\n        logger.info(f'columnType:{columnType} hidden:{hidden}')\n        if columnType == 'coordinates':\n            self.myTable2.mySetColumnHidden('z', hidden)\n            self.myTable2.mySetColumnHidden('y', hidden)\n            self.myTable2.mySetColumnHidden('x', hidden)\n        elif columnType == 'properties':\n            for property in self._myLayer.properties.keys():\n                self.myTable2.mySetColumnHidden(property, hidden)\n        else:\n            logger.warning(f'did not understand columnType:{columnType}')\n\n    def selectInTable(self, selected_data : Set[int]):\n        \"\"\"Select in table in response to viewer (add, highlight).\n\n        Args:\n            selected_data (set[int]): Set of selected rows to select\n        \"\"\"\n        if self._blockDeleteFromTable:\n            #self._blockDeleteFromTable = False\n            return\n\n        logger.info(f'selected_data: {selected_data}')\n\n        self.myTable2.mySelectRows(selected_data)\n\n    def slot_selection_changed(self, selectedRowList : List[int], isAlt : bool):\n        \"\"\"Respond to user selecting a table row.\n\n        Note:\n            - This is coming from user selection in table,\n                we do not want to propogate\n        \"\"\"\n        if self._blockDeleteFromTable:\n            #self._blockDeleteFromTable = False\n            return\n\n        logger.info(f'selectedRowList: {selectedRowList} isAlt:{isAlt}')\n\n        selectedRowSet = set(selectedRowList)\n\n        self._blockUserTableSelection = True\n        self._myLayer.selectItems(selectedRowSet)\n        self._blockUserTableSelection = False\n\n        # if only one row selected then snap z of the image layer\n        if len(selectedRowList) == 1:\n            selectedRow = selectedRowList[0]  # the first row selection\n            self._myLayer.snapToItem(selectedRow, isAlt)\n\n        # TODO (cudmore) getDataFrame is getting from self._myLayer.selected_Data\n        # is this always the same as selectedRowSet?\n        df = self._myLayer.getDataFrame()\n        self.ltp_signalDataChanged.emit('select', selectedRowSet, df)\n\n    def slot_editingRows(self, rowList : List[int], df : pd.DataFrame):\n        \"\"\"Respond to user editing table rows.\n        \"\"\"\n        logger.info('  CONNECTED TO self.myTable2.mtv_signalEditingRows')\n        logger.info('  received rowList and df as follows')\n        print('  rowList:', rowList)\n        print('  df:')\n        print(df)\n\n        logger.info(f'  --&gt;&gt; NOW emit ltp_signalEditedRows')\n\n        self.ltp_signalEditedRows.emit(rowList, df)\n\n    def _deleteRows(self, rows : Set[int]):\n        self._blockDeleteFromTable = True\n        self.myTable2.myModel.myDeleteRows(rows)\n        self._blockDeleteFromTable = False\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.ltp_signalDataChanged","title":"<code>ltp_signalDataChanged = QtCore.Signal(str, set, pd.DataFrame)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Emit signal to the external code when user adds and deletes items. Emits:     (str) event type which can be \"add\", \"move\" or \"delete\"       (pd.DataFrame) for the edited row</p>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.ltp_signalEditedRows","title":"<code>ltp_signalEditedRows = QtCore.Signal(object, object)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Signal emited after user edited table data and we accepted it.</p>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.__init__","title":"<code>__init__(napari_viewer, oneLayer=None, onAddCallback=None)</code>","text":"<p>A widget to display a layer as a table.</p> <p>Allows bi-directional selection and editing.</p> <p>Parameters:</p> Name Type Description Default <code>viewer</code> <code>Viewer</code> <p>Existing napari viewer.</p> required <code>oneLayer</code> <code>layer</code> <p>If given then connect to this one layer,             otherwise, connect to all existing layers.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If napari_viewer does not have a valid selected layer. Designed to work with (points, shapes, labels) layers. and to work with one Napari layer.</p> <p>TODO (cudmore) check params and return of onAddCallback     takes a string and returns ???</p> <p>TODO (cudmore) once we are created with an accpeted layer.     Need to close the plugin (?) if user deletes the layer?</p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def __init__(self, napari_viewer : napari.Viewer,\n                oneLayer=None,\n                onAddCallback=None):\n    \"\"\"A widget to display a layer as a table.\n\n    Allows bi-directional selection and editing.\n\n    Args:\n        viewer (napari.Viewer): Existing napari viewer.\n        oneLayer (layer): If given then connect to this one layer,\n                        otherwise, connect to all existing layers.\n        onAddCallback (func) function is called on shift+click\n            params(set, pd.DataFrame)\n            return Union[None, dict]\n\n    Raises:\n        ValueError: If napari_viewer does not have a valid selected layer.\n            Designed to work with (points, shapes, labels) layers.\n            and to work with one Napari layer.\n\n    TODO (cudmore) check params and return of onAddCallback\n        takes a string and returns ???\n\n    TODO (cudmore) once we are created with an accpeted layer.\n        Need to close the plugin (?) if user deletes the layer?\n    \"\"\"\n    super().__init__()\n\n    warnings.filterwarnings(\n        action='ignore',\n        category=FutureWarning\n    )\n\n    self._viewer = napari_viewer\n\n    if oneLayer is None:\n        oneLayer = self._findActiveLayers()\n\n    # if oneLayer is None:\n    #     logger.error(f'did not find a layer ???')\n\n    # _myLayer is from our class hierarchy to fix interface problems\n    #   with variable layers in napari\n\n    if isinstance(oneLayer, napari.layers.points.points.Points):\n        self._myLayer = _my_layer.pointsLayer(self._viewer, oneLayer, onAddCallback=onAddCallback)\n    elif isinstance(oneLayer, napari.layers.shapes.shapes.Shapes):\n        self._myLayer = _my_layer.shapesLayer(self._viewer, oneLayer, onAddCallback=onAddCallback)\n    elif isinstance(oneLayer, napari.layers.labels.labels.Labels):\n        self._myLayer = _my_layer.labelLayer(self._viewer, oneLayer, onAddCallback=onAddCallback)\n    else:\n        self._myLayer = None  # ERROR\n        logger.error(f'Did not understand layer of type: {type(oneLayer)}')\n        logger.error(f'Expecting a viewer with an active layer in {self.acceptedLayers}')\n        raise ValueError\n\n    #self._layer = oneLayer\n    # actual napari layer\n\n    # we have layer in our list of 'acceptedLayers'\n    self._myLayer.signalDataChanged.connect(self.slot2_layer_data_change)\n    self._myLayer.signalLayerNameChange.connect(self.slot2_layer_name_change)\n\n    # used to halt callbacks to prevent signal/slot recursion\n    self._blockUserTableSelection = False\n    self._blockDeleteFromTable = False\n\n    self._showProperties = True  # Toggle point properties columns\n    self._showCoordinates = True  # Toggle point coordinates columns (z,y,x)\n    self._shift_click_for_new = False  # Toggle new points on shift+click\n    #self._showFaceColor = True\n\n    # If True, will not switch to different layer\n    #self._onlyOneLayer = oneLayer is not None\n\n    #self.myTable = None\n    self._initGui()  # order matters, connectLayer() is accessing table\n                    # but table has to first be created\n\n    self.slot2_layer_name_change(self._myLayer.getName())\n\n    # key binding are confusing\n    # i want keyboard 'a' to toggle selected row, 'accept' column\n    #self.setFocusPolicy(QtCore.Qt.StrongFocus)\n    #self._viewer.bind_key('i', self._key_i_pressed)\n\n    self.refresh()  # refresh entire table\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.connectLayer","title":"<code>connectLayer(layer)</code>","text":"<p>Connect to one layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>layer</code> <p>Layer to connect to.</p> required TODO <p>Need to handle layer=None and just empty the interface</p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def connectLayer(self, layer):\n    \"\"\"Connect to one layer.\n\n    Args:\n        layer (layer): Layer to connect to.\n\n    TODO:\n        Need to handle layer=None and just empty the interface\n    \"\"\"\n    logger.error('TODO (cudmore) need to refactor this !!!')\n    logger.error('  basically all calls to connect have to go through our layer heirarchy in _my_layer ...')\n    return\n\n    #if layer is None:\n    #    return\n\n    if layer is not None and not isinstance(layer, self.acceptedLayers):\n        logger.warning(f'layer with type {type(layer)} was not in {self.acceptedLayers}')\n        return\n\n    logger.info(f'Connecting to layer \"{layer}\"')\n\n    # disconnect from existing (previous) layer\n    if self._layer is not None:\n        self._layer.events.data.disconnect(self.slot_user_edit_data)\n        self._layer.events.name.disconnect(self.slot_user_edit_name)\n        self._layer.events.symbol.disconnect(self.slot_user_edit_symbol)\n        self._layer.events.size.disconnect(self.slot_user_edit_size)\n        self._layer.events.highlight.disconnect(self.slot_user_edit_highlight)\n\n        # special case\n        self._layer.events.face_color.disconnect(self.slot_user_edit_face_color)\n        self._layer._face.events.current_color.disconnect(self.slot_user_edit_face_color)\n\n    self._layer = layer\n\n    # if layer is None, hide interface\n    if self._layer is None:\n        logger.info('no layer selection ,hiding interface')\n        # TODO (cudmore) the following is not needed, just hide the widget\n        #emptyDataFrame = pd.DataFrame()\n        # set name to ''\n        #self.layerNameLabel.setText('')\n        # set table to empty\n        #self._refreshTableData(emptyDataFrame)\n        self.hide()\n        return\n    else:\n        self.show()\n\n    # display the name of the layer\n    self.layerNameLabel.setText(self._layer.name)\n\n    # AttributeError: 'pointsLayer' object has no attribute 'events'\n    self._layer.events.data.connect(self.slot_user_edit_data)\n    self._layer.events.name.connect(self.slot_user_edit_name)\n    self._layer.events.symbol.connect(self.slot_user_edit_symbol)\n    self._layer.events.size.connect(self.slot_user_edit_size)\n    self._layer.events.highlight.connect(self.slot_user_edit_highlight)\n\n    # this does not call our callback ... bug in napari???\n    self._layer.events.face_color.connect(self.slot_user_edit_face_color)\n    # this works but layer is not updated yet\n    try:\n        self._layer._face.events.current_color.connect(self.slot_user_edit_face_color)\n    except (AttributeError) as e:\n        logger.warning(e)\n\n    # important: when user switches layers, napari does not visually switch selections?\n    # but the layer does remember it. Set it to empty set()\n    # otherwise our interface would re-select the previous selection\n    self._layer.selected_data = set()\n    self._selectedData = None\n\n    self._updateMouseCallbacks()\n\n    # TODO: remove this, should by part of map manager\n    # leaving it here as proof-of-concept\n    #self._myLayer.mouse_wheel_callbacks.append(self.on_mouse_wheel)\n\n    # full refresh of table\n    self.refresh()\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.contextMenuEvent","title":"<code>contextMenuEvent(event)</code>","text":"<p>Show a context menu on mouse right-click.</p> <p>This is an inherited function of QWidget.</p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def contextMenuEvent(self, event):\n    \"\"\"Show a context menu on mouse right-click.\n\n    This is an inherited function of QWidget.\n    \"\"\"\n\n    # create the menu\n    contextMenu = QtWidgets.QMenu(self)\n\n    # add menu item actions\n    showCoordinates = contextMenu.addAction(\"Coordinates\")\n    showCoordinates.setCheckable(True)\n    showCoordinates.setChecked(self._showCoordinates)\n\n    showProperties = contextMenu.addAction(\"Properties\")\n    showProperties.setCheckable(True)\n    showProperties.setChecked(self._showProperties)\n\n    #showFaceColor = contextMenu.addAction(\"Face Color\")\n    #showFaceColor.setCheckable(True)\n    #showFaceColor.setChecked(self._showFaceColor)\n\n    contextMenu.addSeparator()\n    shiftClickForNew = contextMenu.addAction(\"Shift+Click for new\")\n    shiftClickForNew.setCheckable(True)\n    shiftClickForNew.setChecked(self._shift_click_for_new)\n\n    #contextMenu.addSeparator()\n    copyTable = contextMenu.addAction(\"Copy Table To Clipboard\")\n\n    contextMenu.addSeparator()\n\n    # all columns in pandas data model\n    columns = self.myTable2.getColumns()\n    for column in columns:\n        isHidden = column in self.myTable2.hiddenColumnSet\n        columnAction = contextMenu.addAction(column)\n        columnAction.setCheckable(True)\n        columnAction.setChecked(not isHidden)\n\n    # all properties in pandas data\n    # these are part of columns\n\n    # show the popup menu\n    action = contextMenu.exec_(self.mapToGlobal(event.pos()))\n\n    # take action\n    if action == showCoordinates:\n        self._showCoordinates = action.isChecked()\n        self.hideColumns('coordinates', not action.isChecked())\n    elif action == showProperties:\n        self._showProperties = action.isChecked()\n        self.hideColumns('properties', not action.isChecked())\n\n    elif action == shiftClickForNew:\n        self._shift_click_for_new = not self._shift_click_for_new    \n        #self._updateMouseCallbacks()\n        self._myLayer._updateMouseCallbacks(self._shift_click_for_new)\n\n    elif action == copyTable:\n        self.myTable2.myModel.myCopyTable()\n\n    elif action is not None:\n        # show/hide individual comuns\n        column = action.text()\n        hidden = column in self.myTable2.hiddenColumnSet\n        self.myTable2.mySetColumnHidden(column, not hidden)  # toggle hidden\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.getTableView","title":"<code>getTableView()</code>","text":"<p>Get underlying QTableView.</p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def getTableView(self):\n    \"\"\"Get underlying QTableView.\n    \"\"\"\n    return self.myTable2\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.hideColumns","title":"<code>hideColumns(columnType, hidden=True)</code>","text":"<p>Hide different sets of columns.</p> <p>Parameters:</p> Name Type Description Default <code>columnType</code> <code>str</code> <p>from - 'coordinates': Show or hide (z, y, x) columns. - 'properties': Show or hide all layer property key columns.</p> required <code>hidden</code> <code>bool</code> <p>If true then column will be hidden, otherwise show.</p> <code>True</code> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def hideColumns(self, columnType : str, hidden : bool = True):\n    \"\"\"Hide different sets of columns.\n\n    Args:\n        columnType (str): from\n            - 'coordinates': Show or hide (z, y, x) columns.\n            - 'properties': Show or hide all layer property key columns.\n        hidden (bool): If true then column will be hidden, otherwise show.\n    \"\"\"\n    logger.info(f'columnType:{columnType} hidden:{hidden}')\n    if columnType == 'coordinates':\n        self.myTable2.mySetColumnHidden('z', hidden)\n        self.myTable2.mySetColumnHidden('y', hidden)\n        self.myTable2.mySetColumnHidden('x', hidden)\n    elif columnType == 'properties':\n        for property in self._myLayer.properties.keys():\n            self.myTable2.mySetColumnHidden(property, hidden)\n    else:\n        logger.warning(f'did not understand columnType:{columnType}')\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.newOnShiftClick","title":"<code>newOnShiftClick(on)</code>","text":"<p>Toggle shift+click for new.</p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def newOnShiftClick(self, on : bool):\n    \"\"\"Toggle shift+click for new.\n    \"\"\"\n    self._myLayer.newOnShiftClick(on)\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.old_on_refresh_button","title":"<code>old_on_refresh_button()</code>","text":"<p>TODO: need to preserve 'accept' column.</p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def old_on_refresh_button(self):\n    \"\"\"TODO: need to preserve 'accept' column.\n    \"\"\"\n    logger.info('')\n    self.refresh()\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.on_bring_to_front_button","title":"<code>on_bring_to_front_button()</code>","text":"<p>Bring the layer to the front in napari viewer.</p> <p>TODO (cudmore): update to _my_layer</p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def on_bring_to_front_button(self):\n    \"\"\"Bring the layer to the front in napari viewer.\n\n    TODO (cudmore): update to _my_layer\n    \"\"\"\n    logger.info('')\n    self._myLayer.bringToFront()\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.refresh","title":"<code>refresh()</code>","text":"<p>Refresh entire table with current layer.</p> Note <p>This refreshes entire table (slow). Should only be used on table creation and layer switching. Do not use for edits like add, delete, change/move.</p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def refresh(self):\n    \"\"\"Refresh entire table with current layer.\n\n    Note:\n        This refreshes entire table (slow).\n        Should only be used on table creation and layer switching.\n        Do not use for edits like add, delete, change/move.\n    \"\"\"\n    #layerDataFrame = self.getLayerDataFrame()\n    layerDataFrame = self._myLayer.getDataFrame(getFull=True)\n    self._refreshTableData(layerDataFrame)\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.selectInTable","title":"<code>selectInTable(selected_data)</code>","text":"<p>Select in table in response to viewer (add, highlight).</p> <p>Parameters:</p> Name Type Description Default <code>selected_data</code> <code>set[int]</code> <p>Set of selected rows to select</p> required Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def selectInTable(self, selected_data : Set[int]):\n    \"\"\"Select in table in response to viewer (add, highlight).\n\n    Args:\n        selected_data (set[int]): Set of selected rows to select\n    \"\"\"\n    if self._blockDeleteFromTable:\n        #self._blockDeleteFromTable = False\n        return\n\n    logger.info(f'selected_data: {selected_data}')\n\n    self.myTable2.mySelectRows(selected_data)\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.slot2_layer_data_change","title":"<code>slot2_layer_data_change(action, selection, layerSelectionCopy, df)</code>","text":"<p>Respond to user interface change through liazon myLayer.</p> <p>TODO (cudmore) data is not used???</p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def slot2_layer_data_change(self, action :str,\n                    selection : set,\n                    layerSelectionCopy : dict,\n                    df : pd.DataFrame):\n    \"\"\"Respond to user interface change through liazon myLayer.\n\n        TODO (cudmore) data is not used???\n    \"\"\"\n    '''\n    logger.info('')\n    print('    action:', action)\n    print('    selection:', selection)\n    print('    data:', data)\n    print('    df:')\n    pprint(df)\n    '''\n\n    if action == 'select':\n        # TODO (cudmore) if Layer is labaeled then selection is a list\n        if isinstance(selection, list):\n            selection = set(selection)\n        self.selectInTable(selection)\n        self.ltp_signalDataChanged.emit(action, selection, df)\n\n    elif action == 'add':\n        #addedRowList = selection\n        #myTableData = self.getLayerDataFrame(rowList=addedRowList)\n        myTableData = df\n        self.myTable2.myModel.myAppendRow(myTableData)\n        self.selectInTable(selection)\n        self.ltp_signalDataChanged.emit(action, selection, df)\n\n    elif action == 'delete':\n        # was this\n        deleteRowSet = selection\n        #logger.info(f'myEventType:{myEventType} deleteRowSet:{deleteRowSet}')\n        #deletedDataFrame = self.myTable2.myModel.myGetData().iloc[list(deleteRowSet)]\n\n        self._deleteRows(deleteRowSet)\n\n        #self._blockDeleteFromTable = True\n        #self.myTable2.myModel.myDeleteRows(deleteRowList)\n        #self._blockDeleteFromTable = False\n\n        self.ltp_signalDataChanged.emit(action, selection, df)\n\n    elif action == 'change':\n        moveRowList = list(selection) #rowList is actually indexes\n        myTableData = df\n        #myTableData = self.getLayerDataFrame(rowList=moveRowList)\n\n        # this is what I call on a keystroke like 'a' for accept but interface is not updated???\n        self.myTable2.myModel.mySetRow(moveRowList, myTableData, ignoreAccept=True)\n\n        logger.warning('!!! we emit ltp_signalDataChanged but it is not connected to anybody')\n        self.ltp_signalDataChanged.emit(action, selection, df)\n    else:\n        logger.info(f'did not understand action: \"{action}\"')\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.slot_editingRows","title":"<code>slot_editingRows(rowList, df)</code>","text":"<p>Respond to user editing table rows.</p> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def slot_editingRows(self, rowList : List[int], df : pd.DataFrame):\n    \"\"\"Respond to user editing table rows.\n    \"\"\"\n    logger.info('  CONNECTED TO self.myTable2.mtv_signalEditingRows')\n    logger.info('  received rowList and df as follows')\n    print('  rowList:', rowList)\n    print('  df:')\n    print(df)\n\n    logger.info(f'  --&gt;&gt; NOW emit ltp_signalEditedRows')\n\n    self.ltp_signalEditedRows.emit(rowList, df)\n</code></pre>"},{"location":"api/_my_widget/#napari_layer_table._my_widget.LayerTablePlugin.slot_selection_changed","title":"<code>slot_selection_changed(selectedRowList, isAlt)</code>","text":"<p>Respond to user selecting a table row.</p> Note <ul> <li>This is coming from user selection in table,     we do not want to propogate</li> </ul> Source code in <code>src/napari_layer_table/_my_widget.py</code> <pre><code>def slot_selection_changed(self, selectedRowList : List[int], isAlt : bool):\n    \"\"\"Respond to user selecting a table row.\n\n    Note:\n        - This is coming from user selection in table,\n            we do not want to propogate\n    \"\"\"\n    if self._blockDeleteFromTable:\n        #self._blockDeleteFromTable = False\n        return\n\n    logger.info(f'selectedRowList: {selectedRowList} isAlt:{isAlt}')\n\n    selectedRowSet = set(selectedRowList)\n\n    self._blockUserTableSelection = True\n    self._myLayer.selectItems(selectedRowSet)\n    self._blockUserTableSelection = False\n\n    # if only one row selected then snap z of the image layer\n    if len(selectedRowList) == 1:\n        selectedRow = selectedRowList[0]  # the first row selection\n        self._myLayer.snapToItem(selectedRow, isAlt)\n\n    # TODO (cudmore) getDataFrame is getting from self._myLayer.selected_Data\n    # is this always the same as selectedRowSet?\n    df = self._myLayer.getDataFrame()\n    self.ltp_signalDataChanged.emit('select', selectedRowSet, df)\n</code></pre>"},{"location":"api/_table_widget/","title":"_table_widget","text":""},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView","title":"<code>myTableView</code>","text":"<p>               Bases: <code>QTableView</code></p> <p>Table view to display list of points in a point layer.</p> Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>class myTableView(QtWidgets.QTableView):\n    \"\"\"Table view to display list of points in a point layer.\n    \"\"\"\n\n    signalSelectionChanged = QtCore.Signal(object, object)\n    \"\"\"Emit when user changes row selection.\"\"\"\n\n    mtv_signalEditingRows = QtCore.Signal(object, object)\n    \"\"\"Emit when user edits a row,\n        e.g. on pressing keyboard 'a' to toggle 'accept' column.\n\n    Args:\n        rows (List[int])\n        df (pd.DataFrame) modified dataframe\n    \"\"\"\n    def __init__(self, parent=None):\n        super().__init__(parent)\n\n        self.myModel = None\n\n        self.blockUpdate = False\n\n        self.hiddenColumnSet = set()\n        self.hiddenColumnSet.add('Face Color')\n\n        self._toggleColOnAccept = 'accept'\n        # Column to toggle on keyboard 'a'\n\n        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                            QtWidgets.QSizePolicy.Expanding)\n\n        self.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers\n                            | QtWidgets.QAbstractItemView.DoubleClicked)\n\n        self.setTabKeyNavigation(False)  # 112022\n\n        # by default focusPolicy() is strong focus QtCore.Qt.StrongFocus\n\n        self.setSelectionBehavior(QtWidgets.QTableView.SelectRows)\n\n        # allow discontinuous selections (with command key)\n        self.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)\n\n        self.setSortingEnabled(True)\n\n        # to allow click on already selected row\n        self.clicked.connect(self.old_on_user_click_row)\n\n    def keyPressEvent(self, event : QtGui.QKeyEvent):\n        \"\"\"\n        Parameters\n        ----------\n        event : PyQt5.QtGui.QKeyEvent\n        \"\"\"\n        logger.info(f'user pressed key text:{event.text()}')\n\n        _handled = False\n        if event.key() == QtCore.Qt.Key_A:\n            if self._toggleColOnAccept is not None:\n                _handled = True\n\n                # toggle selected row(s) 'accept' column\n                rowList = self._getRowSelection()\n                if len(rowList)&gt;0:\n                    self._toggleColumn(rowList, self._toggleColOnAccept)\n\n        if not _handled:\n            # if not handled, call inherited to continue propogation\n            super().keyPressEvent(event)\n\n    def _toggleColumn(self, rowList : List[int], col : str):\n        \"\"\"Toggle a column to True/False.\n\n        e.g. on pressing keyboard 'a' to toggle 'accept' column.\n\n        If col item is '' then it is False\n\n        Parameters\n        ----------\n        rowList : list of int\n        col : str\n            Column name to toggle\n        \"\"\"\n\n        logger.info(f'rowList:{rowList} col:{col}')\n\n        # set the rows at col to True/False\n        _df = self.myModel.myGetData()\n\n        if not col in _df.columns:\n            logger.warning(f'Did not find column \"{col}\" in model dataframe')\n            return\n\n        df = _df.loc[rowList].copy()\n        colVals = df[col].tolist()\n        for idx, colVal in enumerate(colVals):\n            logger.info(f'  {idx} colVal:\"{colVal}\" {type(colVal)}')\n            if colVal=='':\n                # newColVal = True\n                newColVal = 'Yes'\n            else:\n                newColVal = ''  # False\n            colVals[idx] = newColVal\n        # logger.info(f'        setting df col:{col} to {colVals}')\n        df[col] = colVals\n\n        # do not do this directly, wait until slot_editedRows(rows, df)\n        # self.myModel.mySetRow(rowList, df)\n\n        logger.info(f'  --&gt;&gt; emit mtv_signalEditingRows (rowList, df))')\n        logger.info(f'    rowList:{rowList}')\n        logger.info(f'    df is: {df}')\n\n        self.myModel.mySetRow(rowList, df)\n\n        #self.mtv_signalEditingRows.emit(rowList, df)\n\n        #self.slot_editedRows(rowList, df)\n\n        # 20230322, I can't get the interface to refresh after changing the model\n        # logger.info('interface does not refresh after changing the model with setData')\n        # self.xxx\n\n    def setFontSize(self, fontSize : int = 11):\n        \"\"\"Set the table font size.\n\n        This does not set the font size of cells, that is done in model data().\n        \"\"\"\n        aFont = QtGui.QFont('Arial', fontSize)\n        self.setFont(aFont)  # set the font of the cells\n        self.horizontalHeader().setFont(aFont)\n        self.verticalHeader().setFont(aFont)\n\n        self.verticalHeader().setDefaultSectionSize(fontSize)  # rows\n        self.verticalHeader().setMaximumSectionSize(fontSize)\n        #self.horizontalHeader().setDefaultSectionSize(_fontSize)  # rows\n        #self.horizontalHeader().setMaximumSectionSize(_fontSize)\n        self.resizeRowsToContents()\n\n    def slot_editedRows(self, rowList : List[int], df : pd.DataFrame):\n        logger.info('received rowList and df as follows')\n        print('  rowList:', rowList)\n        print('  df:')\n        print(df)\n\n        print('  after user change calling myModel.mySetRoww')\n\n        self.myModel.mySetRow(rowList, df)\n\n    def _getRowSelection(self) -&gt; List[int]:\n        \"\"\"Get the current row(s) selection.\n        \"\"\"\n        selectedIndexes = [self.proxy.mapToSource(modelIndex).row()\n                            for modelIndex in self.selectedIndexes()]\n\n        # reduce to list of unique values\n        selectedIndexes = list(set(selectedIndexes))  # to get unique values\n\n        return selectedIndexes\n\n    def getNumRows(self):\n        \"\"\"Get number of rows from the model.\n        \"\"\"\n        return self.myModel.rowCount()\n\n    def getColumns(self):\n        \"\"\"Get columns from model.\n        \"\"\"\n        return self.myModel.myGetData().columns\n\n    def clearSelection(self):\n        \"\"\"Over-ride inherited.\n\n        Just so we can see this in our editor.\n        \"\"\"\n        super().clearSelection()\n\n    def selectRow(self, rowIdx : int):\n        \"\"\"Select one row.\n\n        Args:\n            rowIdx (int): The row index into the model.\n                it is not the visual row index if table is sorted\n        \"\"\"\n        modelIndex = self.myModel.index(rowIdx, 0)  # rowIdx is in 'model' coordinates\n        visualRow = self.proxy.mapFromSource(modelIndex).row()\n        logger.info(f'model rowIdx:{rowIdx} corresponds to visual row:{visualRow}')\n        super().selectRow(visualRow)\n\n    def mySelectRows(self, rows : Set[int]):\n        \"\"\"Make a new row selection from viewer.\n        \"\"\"\n\n        if self.blockUpdate:\n            return\n\n        # to stop event recursion\n        self.blockUpdate = True\n\n        selectionModel = self.selectionModel()\n        if selectionModel:\n            selectionModel.clear()\n\n            if rows:\n                indexes = [self.myModel.index(r, 0) for r in rows]  # [QModelIndex]\n                visualRows = [self.proxy.mapFromSource(modelIndex) for modelIndex in indexes]\n\n                mode = QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Rows\n                [self.selectionModel().select(i, mode) for i in visualRows]\n\n                logger.warning(f'20221101 FIX SNAP TO SELECTED ROW')\n                column = 0\n                # error row is a QtCore.QModelIndex ???\n                row = visualRows[0]\n                # abb mar 22\n                row = row.row()\n                index = self.model().index(row, column)\n                self.scrollTo(index, QtWidgets.QAbstractItemView.PositionAtTop)  # EnsureVisible\n\n            else:\n                #print('  CLEARING SELECTION')\n                self.clearSelection()\n\n        #\n        self.blockUpdate = False\n\n    def mySetModel_from_df(self, df : pd.DataFrame):\n        myModel = pandasModel(df)\n        self.mySetModel(myModel)\n\n    def mySetModel(self, model : pandasModel):\n        \"\"\" Set the model. Needed so we can show/hide columns\n\n        Args:\n            model (pd.DataFrame): DataFrame to set model to.\n        \"\"\"\n        logger.info('')\n        self.myModel = model\n\n        selectionModel = self.selectionModel()\n        if selectionModel is not None:\n            selectionModel.selectionChanged.disconnect(self.on_selectionChanged)\n\n        self.proxy = QtCore.QSortFilterProxyModel()\n        self.proxy.setSourceModel(model)\n\n        self.myModel.beginResetModel()\n        self.setModel(self.proxy)\n        self.myModel.endResetModel()\n\n        self.selectionModel().selectionChanged.connect(self.on_selectionChanged)\n        #self.selectionModel().currentChanged.connect(self.old_on_currentChanged)\n\n        # refresh hidden columns, only usefull when we first build interface\n        self._refreshHiddenColumns()\n\n    def mySetColumnHidden(self, colStr : str, hidden : bool):\n        \"\"\"Set a column hidden or visible.\n\n        Parameters\n        ----------\n        colStr : str\n            Column to hid or show\n        hidden : bool\n            If True then visible, otherwise hidden\n        \"\"\"\n        _columns = self.myModel.myGetData().columns\n        if not colStr in _columns:\n            logger.error(f'did not find {colStr} in model columns')\n            logger.error(f'  available columns are: {_columns}')\n            return\n\n        if hidden:\n            self.hiddenColumnSet.add(colStr)  # will not add twice\n        else:\n            if colStr in self.hiddenColumnSet:\n                self.hiddenColumnSet.remove(colStr)\n\n        logger.info(f'self.hiddenColumnSet: {self.hiddenColumnSet}')\n\n        self._refreshHiddenColumns()\n        #colIdx = self.myModel._data.columns.get_loc(colStr)\n        #self.setColumnHidden(colIdx, hidden)\n\n    def _refreshHiddenColumns(self):\n        columns = self.myModel.myGetData().columns\n        for column in columns:\n            colIdx = columns.get_loc(column)\n            self.setColumnHidden(colIdx, column in self.hiddenColumnSet)\n\n    def old_on_user_click_row(self, item):\n        \"\"\"User clicked a row.\n\n        Only respond if alt+click. Used to zoom into point\n\n        Args:\n            item (QModelIndex): Model index of one row user selection.\n\n        TODO:\n            This is used so alt+click (option on macos) will work\n                even in row is already selected. This is causing 'double'\n                selection callbacks with on_selectionChanged()\n        \"\"\"                \n        # pure PyQt\n        modifiers = QtWidgets.QApplication.keyboardModifiers()\n        #isShift = modifiers == QtCore.Qt.ShiftModifier\n        isAlt = modifiers == QtCore.Qt.AltModifier\n\n        if not isAlt:\n            return\n\n        row = self.proxy.mapToSource(item).row()\n        logger.info(f'row:{row}')\n\n        selectedRowList = [row]\n        self.signalSelectionChanged.emit(selectedRowList, isAlt)\n\n    def on_selectionChanged(self, selected, deselected):\n        \"\"\"Respond to change in selection.\n\n            Args:\n                selected (QItemSelection):\n                deselected (QItemSelection):\n\n            Notes:\n                - We are not using (selected, deselected) parameters,\n                    instead are using self.selectedIndexes()\n                - Connected to: self.selectionModel().selectionChanged\n        \"\"\"\n\n        if self.blockUpdate:\n            #self.blockUpdate = False\n            return\n\n        # pure PyQt\n        modifiers = QtWidgets.QApplication.keyboardModifiers()\n        isShift = modifiers == QtCore.Qt.ShiftModifier\n        isAlt = modifiers == QtCore.Qt.AltModifier\n\n        # BINGO, don't use params, use self.selectedIndexes()\n        selectedIndexes = [self.proxy.mapToSource(modelIndex).row()\n                            for modelIndex in self.selectedIndexes()]\n\n        # reduce to list of unique values\n        selectedIndexes = list(set(selectedIndexes))  # to get unique values\n\n        logger.info(f'  --&gt;&gt; emit signalSelectionChanged selectedIndexes:{selectedIndexes} isAlt:{isAlt}')\n\n        self.blockUpdate = True  # nov 3, 2022\n        self.signalSelectionChanged.emit(selectedIndexes, isAlt)\n        self.blockUpdate = False  # nov 3, 2022\n\n    '''\n    def old_on_currentChanged(self, current, previous):\n        \"\"\"\n\n        Args:\n            current (QtCore.QModelIndex)\n        \"\"\"\n        modifiers = QtWidgets.QApplication.keyboardModifiers()\n        isShift = modifiers == QtCore.Qt.ShiftModifier\n\n        logger.info('')\n        print(f'  current:{current.row()}')\n        print(f'  previous:{previous.row()}')\n\n        selectedRows = self.selectionModel().selectedRows()\n        print(f'  selectedRows:{selectedRows}')\n\n        #self.signalSelectionChanged.emit(selectedRowList, isShift)\n    '''\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.mtv_signalEditingRows","title":"<code>mtv_signalEditingRows = QtCore.Signal(object, object)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Emit when user edits a row,     e.g. on pressing keyboard 'a' to toggle 'accept' column.</p>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.signalSelectionChanged","title":"<code>signalSelectionChanged = QtCore.Signal(object, object)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Emit when user changes row selection.</p>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.clearSelection","title":"<code>clearSelection()</code>","text":"<p>Over-ride inherited.</p> <p>Just so we can see this in our editor.</p> Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def clearSelection(self):\n    \"\"\"Over-ride inherited.\n\n    Just so we can see this in our editor.\n    \"\"\"\n    super().clearSelection()\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.getColumns","title":"<code>getColumns()</code>","text":"<p>Get columns from model.</p> Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def getColumns(self):\n    \"\"\"Get columns from model.\n    \"\"\"\n    return self.myModel.myGetData().columns\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.getNumRows","title":"<code>getNumRows()</code>","text":"<p>Get number of rows from the model.</p> Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def getNumRows(self):\n    \"\"\"Get number of rows from the model.\n    \"\"\"\n    return self.myModel.rowCount()\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.keyPressEvent","title":"<code>keyPressEvent(event)</code>","text":""},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.keyPressEvent--parameters","title":"Parameters","text":"<p>event : PyQt5.QtGui.QKeyEvent</p> Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def keyPressEvent(self, event : QtGui.QKeyEvent):\n    \"\"\"\n    Parameters\n    ----------\n    event : PyQt5.QtGui.QKeyEvent\n    \"\"\"\n    logger.info(f'user pressed key text:{event.text()}')\n\n    _handled = False\n    if event.key() == QtCore.Qt.Key_A:\n        if self._toggleColOnAccept is not None:\n            _handled = True\n\n            # toggle selected row(s) 'accept' column\n            rowList = self._getRowSelection()\n            if len(rowList)&gt;0:\n                self._toggleColumn(rowList, self._toggleColOnAccept)\n\n    if not _handled:\n        # if not handled, call inherited to continue propogation\n        super().keyPressEvent(event)\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.mySelectRows","title":"<code>mySelectRows(rows)</code>","text":"<p>Make a new row selection from viewer.</p> Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def mySelectRows(self, rows : Set[int]):\n    \"\"\"Make a new row selection from viewer.\n    \"\"\"\n\n    if self.blockUpdate:\n        return\n\n    # to stop event recursion\n    self.blockUpdate = True\n\n    selectionModel = self.selectionModel()\n    if selectionModel:\n        selectionModel.clear()\n\n        if rows:\n            indexes = [self.myModel.index(r, 0) for r in rows]  # [QModelIndex]\n            visualRows = [self.proxy.mapFromSource(modelIndex) for modelIndex in indexes]\n\n            mode = QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Rows\n            [self.selectionModel().select(i, mode) for i in visualRows]\n\n            logger.warning(f'20221101 FIX SNAP TO SELECTED ROW')\n            column = 0\n            # error row is a QtCore.QModelIndex ???\n            row = visualRows[0]\n            # abb mar 22\n            row = row.row()\n            index = self.model().index(row, column)\n            self.scrollTo(index, QtWidgets.QAbstractItemView.PositionAtTop)  # EnsureVisible\n\n        else:\n            #print('  CLEARING SELECTION')\n            self.clearSelection()\n\n    #\n    self.blockUpdate = False\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.mySetColumnHidden","title":"<code>mySetColumnHidden(colStr, hidden)</code>","text":"<p>Set a column hidden or visible.</p>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.mySetColumnHidden--parameters","title":"Parameters","text":"<p>colStr : str     Column to hid or show hidden : bool     If True then visible, otherwise hidden</p> Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def mySetColumnHidden(self, colStr : str, hidden : bool):\n    \"\"\"Set a column hidden or visible.\n\n    Parameters\n    ----------\n    colStr : str\n        Column to hid or show\n    hidden : bool\n        If True then visible, otherwise hidden\n    \"\"\"\n    _columns = self.myModel.myGetData().columns\n    if not colStr in _columns:\n        logger.error(f'did not find {colStr} in model columns')\n        logger.error(f'  available columns are: {_columns}')\n        return\n\n    if hidden:\n        self.hiddenColumnSet.add(colStr)  # will not add twice\n    else:\n        if colStr in self.hiddenColumnSet:\n            self.hiddenColumnSet.remove(colStr)\n\n    logger.info(f'self.hiddenColumnSet: {self.hiddenColumnSet}')\n\n    self._refreshHiddenColumns()\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.mySetModel","title":"<code>mySetModel(model)</code>","text":"<p>Set the model. Needed so we can show/hide columns</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>DataFrame</code> <p>DataFrame to set model to.</p> required Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def mySetModel(self, model : pandasModel):\n    \"\"\" Set the model. Needed so we can show/hide columns\n\n    Args:\n        model (pd.DataFrame): DataFrame to set model to.\n    \"\"\"\n    logger.info('')\n    self.myModel = model\n\n    selectionModel = self.selectionModel()\n    if selectionModel is not None:\n        selectionModel.selectionChanged.disconnect(self.on_selectionChanged)\n\n    self.proxy = QtCore.QSortFilterProxyModel()\n    self.proxy.setSourceModel(model)\n\n    self.myModel.beginResetModel()\n    self.setModel(self.proxy)\n    self.myModel.endResetModel()\n\n    self.selectionModel().selectionChanged.connect(self.on_selectionChanged)\n    #self.selectionModel().currentChanged.connect(self.old_on_currentChanged)\n\n    # refresh hidden columns, only usefull when we first build interface\n    self._refreshHiddenColumns()\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.old_on_user_click_row","title":"<code>old_on_user_click_row(item)</code>","text":"<p>User clicked a row.</p> <p>Only respond if alt+click. Used to zoom into point</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>QModelIndex</code> <p>Model index of one row user selection.</p> required TODO <p>This is used so alt+click (option on macos) will work     even in row is already selected. This is causing 'double'     selection callbacks with on_selectionChanged()</p> Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def old_on_user_click_row(self, item):\n    \"\"\"User clicked a row.\n\n    Only respond if alt+click. Used to zoom into point\n\n    Args:\n        item (QModelIndex): Model index of one row user selection.\n\n    TODO:\n        This is used so alt+click (option on macos) will work\n            even in row is already selected. This is causing 'double'\n            selection callbacks with on_selectionChanged()\n    \"\"\"                \n    # pure PyQt\n    modifiers = QtWidgets.QApplication.keyboardModifiers()\n    #isShift = modifiers == QtCore.Qt.ShiftModifier\n    isAlt = modifiers == QtCore.Qt.AltModifier\n\n    if not isAlt:\n        return\n\n    row = self.proxy.mapToSource(item).row()\n    logger.info(f'row:{row}')\n\n    selectedRowList = [row]\n    self.signalSelectionChanged.emit(selectedRowList, isAlt)\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.on_selectionChanged","title":"<code>on_selectionChanged(selected, deselected)</code>","text":"<p>Respond to change in selection.</p> <p>Parameters:</p> Name Type Description Default <code>selected</code> <code>QItemSelection</code> required <code>deselected</code> <code>QItemSelection</code> required Notes <ul> <li>We are not using (selected, deselected) parameters,     instead are using self.selectedIndexes()</li> <li>Connected to: self.selectionModel().selectionChanged</li> </ul> Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def on_selectionChanged(self, selected, deselected):\n    \"\"\"Respond to change in selection.\n\n        Args:\n            selected (QItemSelection):\n            deselected (QItemSelection):\n\n        Notes:\n            - We are not using (selected, deselected) parameters,\n                instead are using self.selectedIndexes()\n            - Connected to: self.selectionModel().selectionChanged\n    \"\"\"\n\n    if self.blockUpdate:\n        #self.blockUpdate = False\n        return\n\n    # pure PyQt\n    modifiers = QtWidgets.QApplication.keyboardModifiers()\n    isShift = modifiers == QtCore.Qt.ShiftModifier\n    isAlt = modifiers == QtCore.Qt.AltModifier\n\n    # BINGO, don't use params, use self.selectedIndexes()\n    selectedIndexes = [self.proxy.mapToSource(modelIndex).row()\n                        for modelIndex in self.selectedIndexes()]\n\n    # reduce to list of unique values\n    selectedIndexes = list(set(selectedIndexes))  # to get unique values\n\n    logger.info(f'  --&gt;&gt; emit signalSelectionChanged selectedIndexes:{selectedIndexes} isAlt:{isAlt}')\n\n    self.blockUpdate = True  # nov 3, 2022\n    self.signalSelectionChanged.emit(selectedIndexes, isAlt)\n    self.blockUpdate = False  # nov 3, 2022\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.selectRow","title":"<code>selectRow(rowIdx)</code>","text":"<p>Select one row.</p> <p>Parameters:</p> Name Type Description Default <code>rowIdx</code> <code>int</code> <p>The row index into the model. it is not the visual row index if table is sorted</p> required Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def selectRow(self, rowIdx : int):\n    \"\"\"Select one row.\n\n    Args:\n        rowIdx (int): The row index into the model.\n            it is not the visual row index if table is sorted\n    \"\"\"\n    modelIndex = self.myModel.index(rowIdx, 0)  # rowIdx is in 'model' coordinates\n    visualRow = self.proxy.mapFromSource(modelIndex).row()\n    logger.info(f'model rowIdx:{rowIdx} corresponds to visual row:{visualRow}')\n    super().selectRow(visualRow)\n</code></pre>"},{"location":"api/_table_widget/#napari_layer_table._table_widget.myTableView.setFontSize","title":"<code>setFontSize(fontSize=11)</code>","text":"<p>Set the table font size.</p> <p>This does not set the font size of cells, that is done in model data().</p> Source code in <code>src/napari_layer_table/_table_widget.py</code> <pre><code>def setFontSize(self, fontSize : int = 11):\n    \"\"\"Set the table font size.\n\n    This does not set the font size of cells, that is done in model data().\n    \"\"\"\n    aFont = QtGui.QFont('Arial', fontSize)\n    self.setFont(aFont)  # set the font of the cells\n    self.horizontalHeader().setFont(aFont)\n    self.verticalHeader().setFont(aFont)\n\n    self.verticalHeader().setDefaultSectionSize(fontSize)  # rows\n    self.verticalHeader().setMaximumSectionSize(fontSize)\n    #self.horizontalHeader().setDefaultSectionSize(_fontSize)  # rows\n    #self.horizontalHeader().setMaximumSectionSize(_fontSize)\n    self.resizeRowsToContents()\n</code></pre>"},{"location":"api/overview/","title":"Overview","text":"<p>The napari-layer-table plugin is made of a number of files including:</p> <ul> <li>_my_widget.py is the main entry point and all you really need to use the plugin.</li> <li>_my_layer.py a class heirarchy to parallel Napari layers. This serves as a liason between the user interacting with the GUI and the backend..</li> <li>_table_widget.py is derived from QTableView and customizes the display of the data.</li> <li>_data_model.py is derived from QAbstractTableModel and provides the _table_widget with a data model.</li> </ul> <p>See the examples/ folder for how to embed the plugin into your own code.</p>"}]}